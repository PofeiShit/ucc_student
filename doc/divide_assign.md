# DIVIDE_ASSIGN
除法单独拎出来讲
```
void main()
{
	int a;
	a /= 1;
}
```
asm code:
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp // 这里未做优化，a | 1的临时符号也计算了加上a变成8了
.BB0:

.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 汇编代码生成
---
.整数的除法运算，要求源操作数 SRC1 的值被加载到 eax 中。若是有符号数的除法运算,则寄存器 edx 的所有位都被设置为 SRC1 的符号位;如 果是无符号数的除法运算，则寄存器 edx 被置为全 0
. t3: a / b
```
movl a, %eax    // 把src1加载到eax
cdq             // 把符号位扩展到edx寄存器 convert double to qual
idivl b         // 进行除法运算[edx: eax] / SRC2, 商存于eax,余数存于edx， 此时eax中的值就是临时变量t3的值
```
由于在一条 x86 汇编指令中，最多只允许出现 2 个操作数，而中间指令“DST:SRC1 / SRC2”有 3 个操作数， 我们需要产生多条 x86 汇编指令来实现该中间指令
(1) 调用 AllocateReg()函数依次为 SRC1、SRC2 和 DST 分配寄存器。DST 是用于保存运算结果的临时变量，必然可分配到一个寄存器，不妨记为 Rx。而如果 SRC1 和 SRC2 不是临时变量，则没有分配到寄存器
(2) 若 DST 和 SRC1 对应的寄存器不一样，我们可产生一条 movl 指令，把 SRC1 的 值传送到寄存器 Rx 中。若 DST 和 SRC1 对应同一个寄存器，则不必产生用于加载 SRC1 的 movl 指令，此时 SRC1 的值已经在 Rx 中
```
		if (SRC1->reg == X86Regs[EAX])  // 若DST和SRC1对应同一个寄存器
		{
			SRC1->needwb = 0;
			SpillReg(X86Regs[EAX]);
		}
		else // 若DST和SRC1对应的寄存器不一样
		{
			SpillReg(X86Regs[EAX]); // 先把寄存器的内容保存到内存
			Move(X86_MOVI4, X86Regs[EAX], SRC1);  // 把SRC1的值传送到积存器EAX
		}
        SpillReg(X86Regs[EDX]); // 把 edx 寄存器的值回写到内存中, 我们会在[edx:eax] 中存放经符号位扩展后的 SRC1
		UsedRegs = 1 << EAX | 1 << EDX;
		if (SRC2->kind == SK_Constant)
		{
            // 为 SRC2 分配必要的寄存器
			// Because "idivl $10" is illegal
			Symbol reg = GetReg();

			Move(X86_MOVI4, reg, SRC2);
			SRC2 = reg;
		}
        // 产生汇编指令来进行乘法或除法运算
        PutASMCode(code, inst->opds);		
        // 之后寄存器 eax 中存放的是“乘法运算的结果”或者“除 法运算的商”，而寄存器 edx 中存放的是“除法运算的余数”
		if (code == X86_MODI4 || code == X86_MODU4){
			AddVarToReg(X86Regs[EDX],DST);
		}else{
			AddVarToReg(X86Regs[EAX],DST);
		}
		break;
```
我们需要把GetReg()，SpillReg(),AddVarToReg()完善下

MOD和DIV原理一样，最后从EDX取值

