# lecture1
新增static和使用哈希表完善符号表
以下面例子进行讲解
```
static int g_a, g_b;
char g_c;

int main()
{
    return 1;
}
```
生成未优化的汇编代码:
```
# Code auto-generated by UCC

.data

.str0:  .string "hello world"

.lcomm g_a 4
.lcomm g_b 4
.comm g_c 1

.text

.globl  main

main:
        pushl %ebp
        pushl %ebx
        pushl %esi
        pushl %edi
        movl %esp, %ebp
        subl $4, %esp
.BB3:
        movl $1, %eax
        jmp .BB5
.BB4:
.BB5:
        movl %ebp, %esp
        popl %edi
        popl %esi
        popl %ebx
        popl %ebp
        ret
```
## 词法分析
    token.h新增TK_STATIC，keyword.h新增STATIC.
## 语法分析

ParseDeclarationSpecifiers:
    
    生成AstSpecifiers(说明符节点)，说明符节点包含AstToken节点(token成员指向词法分析的CurrentToken).在语法分析阶段不为ty节点赋值,新增解析static的代码，语法阶段允许多个static修饰比如 static static static int a;在语义分析阶段报错

ParseStatement:

    增加TK_BRACE:对应的ParseCompoundStatement

ParseCompoundStatement:

    C 语言的复合语句以左大括号开始，接着是若干条的声明，后面再跟着若干条语句，最后以右大括号结束。在 C 语言中，一旦我们遇到复合语句的左括号，代表这是一个新的作用域的开始，我们可以在这个新的作用域里声明一些新的局部变量，“Level++;”记录了作用域深度的变化，“Level --;”则表示我们在遇到复合语句的右大括号时，就离开了当前作用域

## 符号表
    
bucketLinker:
    
    ```
    typedef struct  bucketLinker{
        struct bucketLinker * link; //用于构造哈希表里的哈希桶
        Symbol sym;                 //指向符号对象
    } * BucketLinker;
    ```

与符号相关的数据结构:

    //  哈希表
    // GlobalIDs 用于存放全局的变量名和函数名
    static struct table GlobalIDs;
    // 指针Identifiers 则指向了在当前作用域中存放变量名和函数名的符号表
    static Table Identifiers;
    //  单链表, 为了后续阶段生成代码的方便，我们还会把函数名对应的符号链接在一起
    // FunctionTails 等指针则始终指向相应符号链的链尾，由此可方便地进行插入操作
    static Symbol *FunctionTail, *GlobalTail, *StringTail;
    // 函数名符号链链首
    Symbol Functions;
    // 全局变量和静态变量所在符号链的链首为指针 Globals
    Symbol Globals;
    // 字符串符号链链首
    Symbol Strings;

AddSymbol:

    ·由于同一个函数名或变量名可以在不同作用域中被多次声明，我们需要把同一个符号加入到不同的符号表中.
    ·每当一个 符号 sym 被加入到某个符号表 tbl 时，我们就会为之创建一个 bucketLinker 对象。当一个符号出现在多个符号表时，就会对应多个 bucketLinker 对象，通过这些 bucketLinker 对象，我们可找到对应的符号
    ·符号表实际上就是一个哈希表，所采用的哈希函数unsigned int h = (unsigned long)sym->name & SYM_HASH_MASK;宏 SYM_HASH_MASK 的值为 127
    ·当哈希表为空时，我们会通过从堆中分配 128 个哈希桶。往符号表里添加一个新的符号。当然，我们往哈希桶中添加的是一个 bucketLinker 对象，该对象的 sym 域指向了对应的符号。


AddVariable:

    用于在当前符号表中添加一个变量名,创建一个variableSymbol对象p并初始化。
    .如果该变量处于全局作用域，或者是static变量，则将其加入Globals链表中，而如果是局部变量，将其加入到当前函数的局部变量链表中。
    .如果该变量位于局部作用域，且是通过extern关键字声明的，把符号p加入GlobalIDs;

AddFunction:

    .函数 AddFunction创建了一个类别为SK_Function 的符号。如果当前所处作用域不是全局作用域，我们通过 AddSymbol()函数，把符号 p 加入到当前符号表 Identifiers 中。UCC 编译器还会用一个单链表来记录所有函数名对应的符号，其链首 Functions 变量，在链尾插入符号 p。在 C 语言中，即使是在局部作用域中声明的函数，也被缺省地当作 extern的函数声明。
    .创建FunctionSymbol节点，p->lastv=&p->params(lastv:last variable)函数符号lastv先指向形参，AddFunction后，lastv再指向locals函数内的变量。然后将节点添加到全局Functions符号表。
    
LookupID:

    ·符号表的检索是从当前符号表开始,如果找不到，则再查找外层的符号表，直到全局符号表为止

DoLookupSymbol:

    ·对符号表的查询操作实际上由DoLookupSymbol函数来完成，计算出内存地址的哈希值，for循环根据这个哈希值在相应的哈希桶上进行查找。如果存在更外层的符号表，且我们想查找外层的符号表，则while条件会成立。


SaveParameterListTable:

    实现了保存当前符号表的功能,只有处理函数定义中的形参列表时，我们才会调用SaveParameterListTable()函数来保存其符号表，以便在检查函数体时进行恢复

RestoreParameterListTable:

    则用于恢复符号表,

EnterParameterList:

    当我们开始处理形参列表时,为新的作用域创建相应的符号表，实际的工作由EnterScope()完成

LeaveParemeterList:

    当我们检查完形参列表时,由该函数完成,实际的工作ExitScope函数完成

EnterScope:

    创建新符号表的工作，
    .先把“代表当前作用域深度“的全局变量Level加1
    .然后创建一个新的符号表，outer指向外层（深度较浅的）符号表，
    .全局变量Identifiers始终指向与当前作用域对应的标志符符号表（存放变量名和函数名等）

ExitScope:

    Identifiers指针指向外层的符号表，同时使Level减1

IsInParameterList:

    用来判断我们是否处在形参列表中，以便进行报警
## 语义分析

CheckGlobalDeclaration:

    .CheckDeclarationSpecifiers()、CheckDeclarator()和DeriveType()正是我们构建类型结构的三部曲
    .调用 LookupID()函数查询符号表，如果是第一次遇到此全局变量,调用AddVariable()将其加入到符号表中

CheckFunction:

    主要包含3个部分:checkDeclarationSpecifiers,checkDeclarator,checkCompoundStatement。再加上两个符号添加的功能.函数符号AddFunction以及形参符号AddVariable 以及根据specs->ty和dec->tyDrvList生成继承类型DeriveType, 函数定义的符号的默认存储类型extern
    .CheckDeclarationSpecifiers,CheckDeclarator,DeriveType构建类型结构的三部曲，
    .接着查符号表，如果是第一次遇到此函数，调用 AddFunction()来把函数相关信息加入到符号表，如果之前已把此标识符声明为其他类型，则报错
    .由于函数的形参和局部变量处于同一个作用域，调用RestoreParameterListTable函数用于恢复“调用CheckDeclarator函数对形参的类型进行检查时，通过 SaveParameterListTable()函数所保存的符号表“，然后将各个形参加入到此符号表中
    .最后调用的CheckCompoundStatement()则用于对函数体进行语义检查，C 语言的函数体实际上就是一个复合语句
    .调用ExitScope退出当前作用域

checkDeclarationSpecifiers:

    .当提到声明说明符时，我们应条件反射般地想到“static const int”，其中 static 被称为存储类说明符，而 const 被称为类型限定符，int 被称为类型说明符,
    .检查存储类说明符，按 C 标准，一个声明中最多只能有一个存储类说明符，即只能是 extern、auto、static 或 register 中的一个
    .当前就是根据spec->tySpecs生成对应ty(T(CHAR)或者T(INT))




## 汇编代码生成

GetAccessName:

    .用于处理整型常数，在 AT&T 汇编指令中其符号形如“$4”
    .用来产生形如“.str0”的字符串名和“.BB2”标号
    .全局变量名和“处于函数体外的静态变量名“仍然可以在汇编代码中出现，p->aname = p->name;
    .为了避免重名，UCC编译器会对“位于函数体内的静态变量名“进行改名，得到的名称形如"c.1"
    .对于局部变量、形式参数和临时变量，在汇编代码中，我们用形如“20(%ebp)”这样的符号来表示，根据在LayoutFrame()函数中计算出来的偏移，来设置相应的符号名
    .在汇编代码中，函数名仍然可以直接使用

DefineCommData:

    GetAccessName得到相应的汇编名字后，如果p->sclass==TK_STATIC,则Print(".lcomm\t%s,%d\n", p->aname, p->ty->size);
