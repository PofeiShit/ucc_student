# BITOR_ASSIGN
```
void main()
{
	int a;
	a |= 1;
}
```
asm code:
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp // 这里未做优化，a | 1的临时符号也计算了加上a变成8了
.BB0:
	movl -4(%ebp), %eax
	orl $1, %eax
	movl %eax, -4(%ebp)
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
.在原有的ParseAssignmentExpression中语法树根节点op:BINARY_OP
.BINARY_OP为一个TokenOps映射数组，token映射binary op或者unary op 详情tokenop.h

## 语义分析
---
.CheckAssignmentExpression, 对于a ｜= 1 的表达式转换为 a = a ｜ 1 来处理, 创建了一个新的语法树结点用来存放运算符｜，而 a 和 1始终对应同一个语法树结点
```
	if (expr->op != OP_ADD_ASSIGN) {
 		AstExpression lopr;
 		CREATE_AST_NODE(lopr, Expression);
 		lopr->op = ops[expr->op - OP_BITOR_ASSIGN]; // |
 		lopr->kids[0] = expr->kids[0]; // a
 		lopr->kids[1] = expr->kids[1]; // 1

 		exrp->kids[1] = (*BinaryOPCheckers[lopr->op - OP_BITOR])(lopr);
 	}
```
.BinaryOPCheckers是个指针数组，根据op调用相应的CheckBitwiseOP，PERFORM_ARITH_CONVERSION调用CommonRealType()函数用来求公共类型，然后对二元运算符的左操作数和右操作数进行必要的转型操作，然后再做个FoldConstant，常量折叠：在编译时进行 1*16 的乘法计算，没有必要把这个计算推迟到运行时，也就是说需要op的左右子节点都为常数才可以。

## 中间代码生成
---
.TranslateAssignmentExpression: dst:变量a对应的符号,对右子树a ｜ 1 TranslateBinaryExpression
.TranslateBinaryExpression:对｜符号的左右子树进行translate，然后Simplify，比如a | 0 = a, a | -1 = -1
.然后TryAddValue用于处理"公共子表达式",暂时没有做，先全部重新计算，先创建临时符号，将a | 1的值保存到该符号中，t := a | 1 GenerateAssign(BOR, temp, a, 1)
.最后将临时符号的值Move给a，a = t, GenerateMove(a, temp);

## 汇编代码生成
---
.EmitBBlock调用EmitAssign对应GenerateAssign。然后根据a的类型和bitor操作符生成对应汇编代码，
``` 
#define ASM_CODE(opcode, tcode) ((opcode << 2) + tcode - I4) 这个值和x86linux.tpl汇编一一对应
```
.DST是临时符号，需要分配寄存器%eax，需要将a的值(SRC1)mov到%eax, 因为a是SK_Variable，汇编符号是根据%ebp生成，所以汇编movl -4(%ebp), %eax
.PutASMCode(code, inst->opds); code = X86_BORI4, 对应汇编TEMPLATE(X86_BORI4,     "orl %2, %0")， orl取GenerateAssign的DST:t和SRC2:1
生成 orl $1, %eax
.EmitMove对应GenerateMove, 	Move(X86_MOVI4, DST, SRC1);就生成movl %eax, -4(%ebp) DST就是a也就是-4(%ebp), SRC1: %eax