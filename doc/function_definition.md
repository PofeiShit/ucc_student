# function definition
函数的定义是如何生成汇编代码

**先以无参函数例子进行讲解**
```
void main()
{
}
```
未优化的汇编代码:
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
.BB0:
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```
## 词法分析

    .token.h添加对应的token，keyword.h添加关键词,多余不再多说，重点讲后面

## 语法分析

    .整个函数用结构体astFunction记录,void就是astSpecifiers成员，main是astDeclarator成员， {}整个就是stmt成员
    .所以void main() ParseDeclaration解析生成相应的语法树. {}里面没有具体的表达式，stmt.c和expr.c不需要care
    .到此语法分析已经结束,返回的是AstFunction结构体

## 语义分析

    .语义分析阶段最主要的两个任务，生成类型系统和生成符号表
    .CheckFunction通过AddFunction给main生成符号，将该符号添加到Functions符号链中,
    .stmt和expr也不必关注

## 中间代码生成

    .经过语义分析后，只需要对函数进行trans即可，全局变量已经在全局符号链表结构中。
    .TranslateFunction函数生成函数定义的中间代码，中间代码的基本结构basic block负责生成函数进入和函数退出的信息，FSYM时刻指向当前的函数，create当前函数的entryBB和exitBB。然后CurrentBB指向entryBB,StartBBlock就是将CurrentBB和下一个BB链接在一起，然后在让CurrentBB指向下个BB。最后为每个BB生成Label也就是.BB0

## 汇编代码生成

    .汇编阶段通过不停的调用EmitFunction搞定
    .EmitFunction先通过Export生成.global main。DefineLabel生成.BB0. 
    .EmitPrologue生成 push ebp; push ebx; push edx; push esi; mov esp ebp; 
    .如果有stmt也就是函数{}有其他代码，那么要继续通过EmitBBlock(bb)生成
    .最后通过EmitEpilogue生成函数结尾 mov ebp esp; pop esi; pop edx; pop ebx; pop ebp;

ps: 按照语法定义，c语言就两种形式，global_declaration和function definition
    也就是int a;和void main() {}
    主要就是生成符号，记录到相对应的链表，然后调用EmitGlobals和EmitFunction函数根据符号的修饰或者限定符号生成相对应的汇编代码。


**有形式参数函数例子进行讲解**
```
void main(int a, char b)
{
}
```
## 词法分析

    .略

## 语法分析

    .上面提到整个函数用结构体astFunction记录,void就是astSpecifiers成员，main是astDeclarator成员， {}整个就是stmt成员，
    .那么就是主要修改astDeclarator，这个结构体再增加记录参数list的成员即可，list的每个成员是int a;类似的声明，解析这个声明生成语法树，分析完毕
    .仍然返回的是AstFunction结构体，这个结构体成员增加了个参数而已

## 语义分析
    
    .语法树新增了形参，对应的语义分析要增加形参的检查，生成整个函数的类型。
    .CheckFunction通过AddFunction给main生成符号，将形参信息保存到符号中（这里就没有局部变量等信息），最后将该符号添加到Functions符号链中,
    
## 中间代码生成

    .形参部分对中间代码没有任何影响

## 汇编代码生成

    .形参对汇编代码生成就是LayoutFrame,但也只是给形参的offset赋值，通过LayoutFrame可以体会到函数调用和函数定义的联系
    .比如熟悉的printf("%d,%d\n", a++, ++a);之类的
    .从右往左入栈就是
    ```
    ++a;
    a++;
    call printf
    ```
    .当然了，没有函数调用形参对汇编代码没有影响，所以和无形参是一样的
