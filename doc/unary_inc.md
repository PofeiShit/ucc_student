# unary ++/--
---
之前把二元运算符简单过了一遍，这里开始单目运算符++和--。
```
void main()
{
    int a;
    ++a;
    --a;
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	movl -4(%ebp), %eax
	addl $1, %eax
	movl %eax, -4(%ebp)
	movl -4(%ebp), %ecx
	addl $-1, %ecx
	movl %ecx, -4(%ebp)
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret
```

## 语法分析
---
在expr.c添加ParseUnaryExpression(),然后ParseBinaryExpression()先调用优先级高的表达式。
在函数中先只增加TK_INC和保留原先的TK_LPAREN分支，解析TK_INC后给语法树结点的op和kids[0]赋值

## 语义分析
---
在exprchk.c添加 CheckUnaryExpression(),然后添加OP_PREINC分支调用TransformIncrement检查前缀++
通过TransformIncrement我们可以发现，++a转换成a+=1处理，创建一个casgn节点，casgn->op = OP_ADD_ASSIGN;随后调用CheckExpression()对+=运算符进行语义检查，原始节点expr的op仍然为OP_PREINC,这样在生成代码时，对前后缀进行区分，从而产生不同的代码

## 中间代码生成
---
在transexpr.c中添加TranslateUnaryExpression(),然后添加OP_PREINC分支调用TranslateIncrement生成OP_ADD_ASSIGN的中间代码。