# lecture1
函数的定义和调用是如何生成汇编代码
以下面例子进行讲解
```
char print_hw(int a, int b)
{
    puts("hello world");
    return '0';
}
int main()
{
    print_hw(3, 4);
    return 1;
}
```
生成未优化的汇编代码:
```
# Code auto-generated by UCC

.data

.str0:  .string "hello world"


.text

.globl  printf_hw

printf_hw:
        pushl %ebp
        pushl %ebx
        pushl %esi
        pushl %edi
        movl %esp, %ebp
        subl $8, %esp
.BB0:
        leal .str0, %eax
        pushl %eax
        call puts
        addl $4, %esp
        movl $48, %eax
        jmp .BB2
.BB1:
.BB2:
        movl %ebp, %esp
        popl %edi
        popl %esi
        popl %ebx
        popl %ebp
        ret

.globl  main

main:
        pushl %ebp
        pushl %ebx
        pushl %esi
        pushl %edi
        movl %esp, %ebp
        subl $4, %esp
.BB3:
        pushl $4
        pushl $3
        call printf_hw
        addl $8, %esp
        movl $1, %eax
        jmp .BB5
.BB4:
.BB5:
        movl %ebp, %esp
        popl %edi
        popl %esi
        popl %ebx
        popl %ebp
        ret
```
## 词法分析
    这部分没啥好具体讲的，添加对应的关键词return即可
## 语法分析

ParseExternalDeclaration:

    .外部声明由“函数定义”或“声明”构成.
    .声明包含说明符+声明子(比较难翻译,理解成这个声明语句想要具体声明个啥符号) ex:int(说明符) print_hw(名字声明子)(int a, int b)
    .由于声明（declaration）和函数定义（function-definition）有共同的前缀，UCC 编译器为了简化语法分析的工作,调用 ParseCommonHeader()函数，完成了这部分公共前缀的分析, 此时我们会误把“void a6(void)=3, a7(void)”当作合法的输入
    .如果我们要分析的正是一个声明（declaration），则通过\调用的函数ParseCommonHeader()，就基本完成了对声明的分析工作。但如果要分析的是一个函数定义，则需要作进一步的修正，调用函数 GetFunctionDeclarator检查一下所构造的语法树上，是否存在 kind 域为 NK_FunctionDeclarator 的结点
    接着创建AstFunction节点(包含函数声明子和compoundStatement)。

ParseCommonHeader:
    
    先parse specifiers(说明符:可以理解为对要声明的xxx的详细说明)，然后再parse declarator(声明子:理解为int print_hw(int a, int b)就是声明了一个返回值为int类型,形参为两个int, int类型的print_hw函数.)

ParseDeclarationSpecifiers:
    
    生成AstSpecifiers(说明符节点)，说明符节点包含AstToken节点(token成员指向词法分析的CurrentToken).在语法分析阶段不为ty节点赋值

ParseDeclarator:

    目前就直接调用ParsePostfixDeclarator

ParsePostfixDeclarator:

    中序遍历,先ParseDirectDeclarator(print_hw),然后根据符号判断是啥后缀('(', '[', '.'),创建对应的节点(FunctionDeclarator,funcDec->dec=dec),再ParseParameterTypeList(int a, int b),最后再消耗掉对应的')', ']'符号

ParseDirectDeclarator:
    
    创建NameDeclarator节点，赋值dec-id=print_hw

ParseParameterTypeList:

    创建ParameterTypeList节点，List包含paramDecls(形参声明节点)。根据CurrentToken是否为TK_COMMON跳出循环，paramDecls->next指向下一个形参声明

    ParseParameterDeclaration:创建ParamterDeclaration节点,声明包含说明符+声明子

GetFuncionDeclarator:
    
    parseCommonHeader将真正的声明和函数放在一起，所以需要通过GetFunctionDeclarator区分函数声明。对上面的声明(AstDeclaration->dec)再分析
    因为还没有添加其他的符号比如'*'等。fdec=(AstDeclartion->dec)。不相等的情况可以看下面的例子：

    ```
    /**
    int ** f(int a, int b);
    astPointerDeclarator-> astPointerDeclarator ->  astFunctionDeclarator --> astDeclarator
    (dec)									        (fdec )
    */
    ```

ParseCompoundStatement:

    对函数体的分析，创建CompoundStatement节点，包含语句节点列表(ParseStatement)

ParseStatement:

    根据CurrentToken做相应statement parse。ParseExpressionStatement(puts("hello world"))以及ParseReturnStatement(return '0');

ParseExpressionStatement:

    创建ExpressionStatement节点.再ParseExpression

ParseExpression:

    当前就直接调用ParsePostfixExpression

ParsePostfixExpression:

    中序遍历，先ParsePrimaryExpression(puts),再根据CurrentToken。创建Expressio节点。赋值op=OP_CALL,以及p->kids[0] = puts。然后再Parse右节点("hello world")。如果是多个参数，p->kids[1]->next指向下一个节点。最后消耗掉")"符号即可

ParsePrimaryExpression:

    创建Expression节点，根据CurrentToken (TK_ID:puts,  TK_INTCONST: 'a', 1, TK_STRING: "hello world")赋值对应op（OP_ID，OP_CONST, OP_STR)。TK_INTCONST的ty为T(INT)基本类型(char类型在这里也是T(INT),这个会再语义分析调整类型)。TK_STRING的ty为ARRAY.只有 OP_CONST 和 OP_STR 对应结点的类型信息是完整的，语法树中其他结点的类型信息需要在语义分析时通过符号表并结合类型规则进行推导
    
ParseReturnStatement:

    创建RetrunStatement节点。然后ParseExpression。

ParseTranslationUnit：

    以上一个函数定义或者int a;就分析完成.根据是否到TK_END直到分析完cpp中所有的函数后者全局声明。

## 语义分析

CheckFunction:

    主要包含3个部分:checkDeclarationSpecifiers,checkDeclarator,checkCompoundStatement。再加上两个符号添加的功能.函数符号AddFunction以及形参符号AddVariable 以及根据specs->ty和dec->tyDrvList生成继承类型DeriveType
    .CheckDeclarationSpecifiers,CheckDeclarator,DeriveType构建类型结构的三部曲，
    .接着查符号表，如果是第一次遇到此函数，调用 AddFunction()来把函数相关信息加入到符号表，如果之前已把此标识符声明为其他类型，则报错
    .然后将各个形参加入到此符号表中
    .最后调用的CheckCompoundStatement()则用于对函数体进行语义检查，C 语言的函数体实际上就是一个复合语句

checkDeclarationSpecifiers:

    当前就是根据spec->tySpecs生成对应ty(T(CHAR)或者T(INT))

CheckDeclarator:

    .根据节点类型（NameDeclarator,FunctionDeclarator)做对应的检查
    .函数 CheckDeclarator()要做的事情就是遍历Declarator链表，收集 Declarator 链表上各结点的类型信息，最终再通过 DeriveType()函数，综合由 CheckDeclarationSpecifiers()和 CheckDeclarator()这两个函数得来的类型信息，为标识符 print_hw、main 构造出完整的类型结构

CheckFunctionDeclarator:

    .分配funcDec->sig。创建了一个 struct signature 对象用于保存函数的形参列表的类型信息
    .sig->hasProto:函数原型,sig->hasEllipsis:是否有...符号，sig->params:具体的形参
    .接着创建了一个向量对象用于保存各形参
    .然后调用 CheckParameterTypeList()获得其形参类型信息
    .创建了一个 struct typeDerivList 对象，用来保存从 astFunctionDeclarator 结点中收集来的类型信息，设置类型构造符为 FUNCTION_RETURN（即函数类型），保存形参的类型信息
    .check完参数列表后,ALLOC(funcDec->tyDrvList)。生成函数声明子的类型。ctor=FUNCTION_RETURN,sig=funcDec->sig,id=funcDec->dec->id;

CheckParameterTypeList:

    .CheckParameterTypeList()函数来获取形如(int a,int b)的参数列表中的类型信息
    .while 循环实现了对各个形参的检查，调用函数CheckParameterDeclaration()完成了对某个形参的检查。

CheckParameterDeclaration:

    .check参数列表的每个参数声明:checkDeclarationSpecifiers和CheckDeclarator。再加上DeriveType完成类型收集
    .根据specs->ty和dec->tyDrvList(NULL)生成继承类型DeriveType(T(INT)),如果形参ty为FUNCTION,则将其转换为POINTER类型。
    .然后ALLOC(param)。添加到funcDec->sig->params

AdjustParameter:

    .对于形参中的数组和函数类型，按 C 标准的规定，我们需要将其调整为指针类型，
    .这里是函数定义中的形参类型转换，后面还有个函数Adjust，也是需要将数组和函数转换成指针类型，是用于函数调用，传入参数的转换

AddFunction:
    
    .函数 AddFunction创建了一个类别为SK_Function 的符号。如果当前所处作用域不是全局作用域，我们通过 AddSymbol()函数，把符号 p 加入到当前符号表 Identifiers 中。UCC 编译器还会用一个单链表来记录所有函数名对应的符号，其链首 Functions 变量，在链尾插入符号 p。在 C 语言中，即使是在局部作用域中声明的函数，也被缺省地当作 extern的函数声明。
    .创建FunctionSymbol节点，p->lastv=&p->params(lastv:last variable)函数符号lastv先指向形参，AddFunction后，lastv再指向locals函数内的变量。然后将节点添加到全局Functions符号表。

AddVariabe:

    创建VaribaleSymbol节点，根据sclass将变量符号节点放到全局Global表还是FSYM符号的lastv中。

CheckCompoundStatement:

    根据stmt->kind调用相应的CheckExpressionStatement和CheckReturnStatement

CheckReturnStatement:

    调用CheckPrimaryExpression检查return的表达式,随后Adjust表达式类型,随后cast表达式真正类型

CheckExpressionStatement:   CheckExpressionStatement

CheckExpressionStatement:   CheckPostfixExpression

CheckPostfixExpression:     CheckFunctionCall

CheckFunctionCall:

    .对形如 f(a,b,c)的函数调用进行语义检查时，需要先查找符号表，看看函数 f 是否已经声明过
    .puts函数并未声明，所以这里直接给符号的ty赋值为DefaultFunctionType添加到全局函数符号表
    .print_hw已经定义过，CheckExpression检查,接着通过Adjust将puts函数的类型转换为指针类型，
    检查函数调用的参数CheckArgument

LookupID:

    对于这个例子,当前就是简单把name和Functions中的符号的name做比较
    ```
    Symbol LookupID(char *name)
    {	
        Symbol head = Functions;
        while (head) {
            if (strcmp(head->name, name) == 0) {
                break;
            }
            head = head->next;
            
        }
        return head;
    }
    ```

CheckPrimaryExpression:

    .对于形如 123 这样的常量，在语法分析时我们就已经在其语法树结点中记录了类型信息，在语义检查时，不需要做其他工作，直接返回即可。
    .而对于字符串，UCC 编译器会为之取一个形如“.str1”这样的名称，并且将字符串加入到一个链表中，以便在代码生成时，能生成.str0:  .string "hello world"的汇编代码。这个工作主要由函数 AddString()来完成。
    .被 UCC 编译器命名后的字符串，就相当于具有了标识符的语法地位，所以将字符串对应语法树结点的 op 域改为 OP_ID。
    .在 C 语言中，我们还可以读取字符串的地址，例如 printf("%p \n",&"abc")，这相当于字符串“abc”具有 C 程序员可见的内存地址，
    .后部分用于处理标志符，这需要由函数 LookupID()查一下符号表，看看标志符是否已经声明过，如果是未声明就使用则报错，紧接着通过函数 AddVariable()往符号表里添加一个 int 型的符号，这是“将错就错”的策略，以便后续的语义检查能继续进行下去
    .对于其他的标识符，我们把从符号表中查找得来的类型信息复制到语法树结点上

AddString:

    主要是为这些字符串取一个名称,的 FormatName()函数完成了这个工作，这是一个C 语言的变参函数

CheckArgument:
    
    .检查的内容包括实参个数是否与形参个数吻合，实参与形参在类型上是否匹配。
    .如果函数声明形如 f(void)，即不存在参数，则设置相应标志位为 1，表示对函数实参已检查完毕，直接返回
    .对于形如 f(int,int,int)的函数声明来说，f 不是变参函数，若当前要检查的实参是最后一个，则置相应标志位为 1
    .出于内存对齐的考虑，C 编译器通常会把小于 int 类型的实参(例如 char 或者 short)转换成 int后入栈，由编译器隐式进行的转型操作
    .parLen = LEN(fty->sig->params)入参的个数，CheckExpression进行实参表达式的语义检查，接着也需要Adjust调整参数类型(如果为函数或者数组，需要转成指针)

Adjust:
    
    函数和数组类型都转换成指针类型

CheckReturnStatement:

    CheckExpression检查return的表达式
    然后判断表达式是否可以赋值给返回类型，最后将表达式cast到返回的类型

## 中间代码生成

TranslateFunction:
    
    .不论函数内部的控制流有多复杂，整个函数定义都只有一个入口和一个出口,调用 CreateBBlock()来创建这两个基本块
    .调用 TranslateStatement()实现了对函数体的翻译，函数体实际上是一个复合语句
    .原始代码的Optimize()函数用于对生成的中间代码进行优化，这里就注释了,主要是理解编译器的整体过程，优化不考虑
    .while 循环用于给各个基本块命名，形如“BB1”和“BB2”等
    .CreateBBlock()函数返回后，新创建的基本块对象并未加入到双向链表中。只有调用了StartBBlock(bb)函数后，我们才会把函数参数bb 所指向的基本块对象加入到双向链表中

CreateBBlock:

    ```
    BBlock CreateBBlock(void)
    {
        BBlock bb;

        CALLOC(bb);

        bb->insth.opcode = NOP; //行用于设置头结点为空指令 NOP（No Operation 的缩写，即“无任何实际运算”）。
        bb->insth.prev = bb->insth.next = &bb->insth;
        return bb;
    }
    ```

TranslateFunctionCall:

    .如果我们遇到的 expr->kids[0]是函数名 f 对应的语法树结点，则通过TranslateExpression(),实际调用的是TranslatePrimaryExpression()函数
    在这情况下我们不需要为函数名 f 产生取地址指令，直接返回 f 即可.通过设置 isfunc 为 0，可以使得PrimaryExpression的if 条件不成立。 
    .最后的while 循环用来依次对各个实参表达式进行Translate，并把得到的结果插入到向量 args 中。
    .如果返回值不是 void 类型，我们就创建一个临时变量用来存放函数的返回值。调用 GenerateFunctionCall()函数来生成 CALL 指令

TranslatePrimaryExpression:

    翻译基本表达式（常量和 ID 等）。对于数组名和函数名，我们在AddressOf()函数来生成取地址的指令，对于其他的标识符，我们在语义检查时已经查过符号表，此处直接返回 expr 结点中保存的符号即可

GenerateFunctionCall：

    用于生成形如“t1 : f();”的中间代码，该中间代码的运算符实际上是CALL，recv 对应函数返回值 t1，faddr 相当于函数的首地址 f，args 向量用于存放多个实参，初始化 CALL 指令，并AppendInst添加到当前基本块中

AppendInst:

    ```
    CurrentBB->insth.prev->next = inst;
	inst->prev = CurrentBB->insth.prev;
	inst->next = &CurrentBB->insth;
	CurrentBB->insth.prev = inst;
    ```
    用于往当前基本块中添加一条中间代码，4 条语句用于实现双向链表的插入操作

AddressOf:

    可以生成“t1:&arr；”的取地址指令, 取地址的结果保存到创建的临时变量中。

TranslateReturnStatement:
    
    生成两条中间代码指令 RET ops[0] 和JMP symbol(dstBB) 
    ```
    static void TranslateReturnStatement(AstStatement stmt)
    {
        AstReturnStatement retStmt = AsRet(stmt);

        if (retStmt->expr)
        {
            GenerateReturn(retStmt->expr->ty, TranslateExpression(retStmt->expr));
        }
        GenerateJump(FSYM->exitBB);
        StartBBlock(CreateBBlock());
    }
    ```

GenerateReturn:

    ```
    void GenerateReturn(Type ty, Symbol src)
    {
        IRInst inst;

        ALLOC(inst);
        src->ref++;
        inst->ty = ty;
        inst->opcode = RET;
        inst->opds[0] = src;
        inst->opds[1] = inst->opds[2] = NULL;
        AppendInst(inst);
    }
    ```

GenerateJump:

    ```
    void GenerateJump(BBlock dstBB)
    {
        IRInst inst;

        ALLOC(inst);
        dstBB->ref++;
        DrawCFGEdge(CurrentBB, dstBB);
        inst->ty = T(VOID);
        inst->opcode = JMP;
        inst->opds[0] = (Symbol)dstBB;
        inst->opds[1] = inst->opds[2] = NULL;
        AppendInst(inst);
    }
    ```
## 汇编代码生成

EmitTranslationUnit:

    会为整个翻译单元产生汇编代码
    BeginProgram()函数作用:#Code auto-generated by UCC
    Segment(DATA):  .data //全局静态数据区

EmitStrings:

    UCC 编译器可以为字符串产生.str0: .string "b = %f \012"字符数组,UCC 编译器会隐式地为字符串取名,按 C 语言的语法，由 C 程序员命名的变量名或函数名不会以“.”开始，这就可保证不会发生名称上的重名.
    .生成.str0:  .string "hello world"

EmitGlobals:

    EmitGlobals()函数用于处理 C 程序员定义的全局变量,
    .globl a
    a: .long 10

EmitFunctions:

    通过 while 循环，调用 EmitFunction()来为各个函数产生汇编代码

EmitFunction:

    用于产生函数 print_hw 和 main 对应的汇编代码
    行调用的 Export()函数用于在 Linux 平台上产生形如“.globl print_hw”和".global main"的函数声明
    调用的 LayoutFrame()函数用来计算“形式参数、局部变量和临时变量”在活动记录中的偏移，并返回“局部变量和临时变量”在栈中所占内存的总和
    调用 EmitPrologue()来产生“序言”
    通过 while 循环，我们可为各基本块产生汇编代码，主要调用的 EmitBlock()函数来完成。
    调用的EmitEpilogue()函数来产生“尾声”部分，

LayoutFrame:

    .按照 C 标准的规定，在被调函数返回后，寄存器ebx、esi 和 edi 的值要和函数调用前的值一样，这些寄存器被称为“保值寄存器”,UCC 编译器会在“函数的序言”中把这几个寄存器的值入栈；而在“函数的尾声”中恢复这几个寄存器的值，从而实现“保值”的要求。
    .当被调函数返回时，寄存器 ebp 需要再次指向主调函数的活动记录，因此被调函数也要在栈中先保存 ebp 寄存器的值，因此总共需要由被调函数保护的寄存器有 4 个. 即宏 PRESERVE_REGS 所对应的值
    栈的布局图
    ```
    /***************************************
        function(parameter1, parameter2, ....)
        栈空间示意图：
        ...............
        parameter2
        parameter1 20(%ebp)
        return address 16(%ebp)
        ebp 12(%ebp)
        ebx 8(%ebp)
        esi 4(%ebp)
        edi ______________ 0(%ebp)
        局部变量与临时变量 -4(%ebp)
    ********************************************/
    ```
    .第 1 个形参的位置为“20(%ebp)”，而第 1 个局部变量或临时变量的位置为“-4(%ebp)”,
    .while 循环用于为各个形参计算其偏移，其偏移从 20 开始依次递增,while 循环用于为局部变量和临时变量计算偏移，其偏移从“-4”开始依次递减, 返回局部变量和临时变量所占用的栈空间的总和
    .printf_hw函数中，调用puts函数为“hello world"产生一个临时变量，以及recv返回值产生临时变量，所以stksize=offset=8。subl $8, %esp
    .main函数中，只有recv返回值产生临时变量,所以stksize=4. subl $4, %esp

GetAccessName:

    .用于处理整型常数，在 AT&T 汇编指令中其符号形如“$4”
    .用来产生形如“.str0”的字符串名和“.BB2”标号
    .对于局部变量、形式参数和临时变量，在汇编代码中，我们用形如“20(%ebp)”这样的符号来表示，根据在LayoutFrame()函数中计算出来的偏移，来设置相应的符号名
    .在汇编代码中，函数名仍然可以直接使用

EmitBBlock:

    while 循环会遍历基本块中的所有中间代码,调用EmitIRInst()函数为当前中间代码 inst 产生汇编指令, 通过查函数表的套路来实现相应函数的调用, 表格 Emitter 中存放了形如函数名 EmitJump, EmitAddress

EmitAddress:

    .调用 AllocateReg()函数为 ADDR 指令里的临时变量 DST 分配一个寄存器，接着产生汇编指令把 SRC1 的地址加载到 DST 对应的寄存器中
    .puts函数的参数是hello world字符串，当成数组，所以需要生成取地址，ucc生成的汇编leal .str0, %eax

AllocateReg:

    .参数 index 表示要为哪一个操作数分配寄存器，取值范围为{0，1，2}, 分别对应 DST、SRC1 和 SRC2, UCC 编译器只为临时变量分配寄存器。如果当前操作数是“已经分配过寄存器”的临时变量,则设置标志位, 表示相应的寄存器会被用于“当前中间指令的翻译”,
    .对于例子的函数直接分配eax寄存器，调用 AddVarToReg()把临时变量 p 添加到寄存器 reg 的链表reg->link 中，
    .在 UCC 编译器内部，只有把临时变量 p 添加到寄存器 reg 对应的链表 reg->link时，才意味着我们确实把寄存器 reg“长期”分配给了临时变量 p
    .在目前版本的 UCC 中，该链表最多只存放一个临时变量

EmitCall:

    函数调用对应的中间指令如下所示：
    //中间指令的四元式： < opcode, DST, SRC1, SRC2>
    <CALL, 用于接收返回值的变量 recv, 函数名 func, 参数列表[arg1,arg2, … ,argn]>
    .根据 C 函数的调用约定，我们需要把参数从右向左入栈（即从 argn 到 arg1 依次入栈），不妨记这些参数所占用的栈内存为 stksize 字节, 当函数调用返回后，主调函数要负责把这些参数出栈，这可通过形如“addl stksize, %esp”的汇编指令来实现, 主调函数在产生 call汇编指令之前，要对 eax、ecx 和 edx 这 3 个寄存器进行必要的回写操作, 而 ebx、esi 和 edi这 3 个寄存器则由被调函数负责保存, UCC 编译器会在所有函数的入口处保存这几个寄存器。为了加快返回值的传递，我们会尽量把返回值放在寄存器中: 若返回值为整型，则存于 eax 寄存器中(我们只考虑 32 位平台)；
    ```
    int myadd(int a,int b)；
    result = myadd(num1,num2);
    ///////////////对应汇编代码////////////
    pushl num2 //参数 num2 入栈
    pushl num1 //参数 num1 入栈
    call myadd //函数调用
    addl $8, %esp //所有参数出栈
    movl %eax, result //取返回值
    ```
    .PushArgument把参数从右到左依次入栈，print_hw函数调用puts函数,"hello world”需要入参，因为在EmitAddress为临时变量分配了%eax寄存器，PushArgument的PutASMCode产生的汇编代码为push %eax
    .main函数调用print_hw函数，参数4,3对应的汇编代码为 push $4和push $3

    .调用 SpillReg()函数对寄存器 eax、ecx和 edx 进行必要的回写，
    .产生函数调用指令，形如“call myadd”或者“call * fptr”，把所有参数出栈。call puts和call print_hw
    .addl $4, %esp表示hellow world出栈，addl $8, %esp：参数4，3出栈
    .从寄存器 eax 或 edx 中获取 “整数返回值,rty->size=1. 调用Move(X86_MOVI1, DST, X86ByteRegs[EAX]);在GetAccessName函数DST->kind为SK_Temp(是返回值的临时变量),而且符号的sclass不为extern和static,产生汇编代码:movb %al, -4(%ebp)

PushArgument:

    PutASMCode(X86_PUSH, &p);


SpillReg:

    .把寄存器中保存的值写回内存,这样该寄存器又可再次被分配,这个动作常被称为“寄存器溢出”, 
    .“p->needwb”不为 0 时，表示临时变量 p 在寄存器和内存中的值已经不一致, 而“p->ref > 0”表示临时变量 p 还需要再次被使用，当这两个条件都符合时，我们才会调用 StoreVar()函数来产生写内存的指令,
    .在目前版本的 UCC 编译器中，一个寄存器通常只保存一个临时变量的值, while 语句的循环体只执行一次。换言之，链表 X86Regs[i]->link和链表 reg->link 上的元素个数都不会超过 1 个,设置 p->reg 为 NULL，表示临时变量 p 的值不再保存在寄存器中。

StoreVar:

    Move(X86_MOVI4, v, reg);

EmitReturn:

    当遇到 C 程序里的形如“return expr;”的函数返回语句时，UCC 编译器会产生以下中间代码。其中，expr 代表 C 程序员编写的表达式,而 retVal 是 UCC 编译器生成的用于存放返回值的临时变量,当然，经过 UCC 编译器的中间代码优化后，retVal 也可能是 C 程序员命名的变量，而非临时变量
    return expr;
    /////////对应中间代码////////////
    <RET, retVal, NULL,NULL> //中间指令 RET 只是准备好返回值
    <JMP, exitBB,NULL,NULL> //跳往函数的唯一出口
    在函数的唯一出口对应的基本块 exitBB 中，UCC 编译器会通过 EmitEpilogue()函数产生以下汇编代码，用于从被调函数返回到主调函数
    exitBB:
        movl %ebp, %esp
        popl %edi
        popl %esi
        popl %ebx
        popl %ebp
        ret
    因此，中间指令<RET, retVal, NULL,NULL>所要完成的工作只是传递返回值
    .返回值是整数或者返回值是大小落在{1，2，4，8}中的结构体对象,把返回值传送到“寄存器 eax 或者 edx”中
    .print_hw函数return的表达式类型的size=1，调用Move(X86_MOVI1, X86ByteRegs[EAX], DST)产生movb $48, %al。这个正好在EmitCall函数中使用movb %al, -4(%ebp)获得返回值,
    .main函数Move(X86_MOVI4, X86Regs[EAX], DST)产生movl %1, %eax

EmitJump:

    用于为无条件跳转指令产生汇编代码,在控制流离开上述基本块时，我们也要把临时变量的值写回内存，这可通过调用的 ClearRegs(), X86_JMP到inst->opds的第0个元素也就是DST
    .print_hw:jmp .BB2
    .main: jmp .BB5

ClearRegs:

    ```
    void ClearRegs(void)
    {
        int i;

        for (i = EAX; i <= EDI; ++i)
        {
            if (X86Regs[i])
                SpillReg(X86Regs[i]);
        }
    }
    ```
    ClearRegs()函数来回写“eax、ebx、ecx、edx、esi 和 edi”这 6 个寄存器

PutASMCode:

    /**
        For example:
            TEMPLATE(X86_JMP,      "jmp %0")
        If code is X86_JMP,
            fmt is "jmp %0"
    */
	char *fmt = ASMTemplate[code];通过模板号 X86_ADDF8，查表得到对应的汇编指令模板“faddl %2”,当然在调用PutASMCode()前，我们需要先为中间指令里的操作数分配必要的寄存器

    .while 循环用来处理形如“faddl %2”的汇编指令模板,我们会将占位符“%0”、“%1”和“%2”替换为相应的操作数名称,如果操作数的值已经被加载到寄存器中，则输出对应寄存器的名称，形如“%eax”, 否则调用分析过的函数 GetAccessName()，输出操作数的名称，形如“number”或者“20(%ebp)”, 
    
    if (*fmt == '%'){// %eax
        PutChar('%');
    处理模板中形如“%%eax”的字符串，在 AT&T 的汇编指令中，寄存器名前要加一个“%”，由于在 UCC 的汇编指令模板中，符号“%”已经被当作转义字符，因此用“%%”表示“%”本身。模板中的“%%eax”经 PutASMCode()函数处理后，会得到“%eax”，其中的“eax”会由PutChar(*fmt);进行输出。

