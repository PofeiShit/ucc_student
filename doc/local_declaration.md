# local declaration
局部声明是如何生成汇编代码
以下面例子进行讲解
```
void main()
{
    int a;
}
```
生成未优化的汇编代码:
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $4, %esp
.BB0:
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```
## 词法分析
---
 略
## 语法分析
---
.前面解析不写了， 直接到ParseCompoundStatement解析函数体{}，解析声明ParseDeclartion(), 也就是DeclarationSpecifiers和Declarator,和global declaration一样

## 语义分析
---
.CheckCompoundStatement调用CheckLocalDeclaration，两步走: specifiers和declarator生成类型，然后创建变量a对应的符号，并且添加到符号表，AddVariable里面和global_declartion添加符号的区别就在stgclass, 我们知道local是分配在栈上的，global是分配数据区的。因此这个符号和FSYM相关
```
	if (Level == 0 || sclass == TK_STATIC)
	{   // global
		*GlobalTail = (Symbol)p;
		GlobalTail = &p->next;
	}
	else if (sclass != TK_EXTERN)
	{   // local
		*FSYM->lastv = (Symbol)p;
		FSYM->lastv = &p->next;
	}
```

## 中间代码生成
---
声明跟中间代码没有关系

## 汇编代码生成
---
.这是一个局部变量，在function_call也讲了，局部变量和临时变量在layoutFrame会在栈上预留大小的。对应就是subl $4, %esp