# typedef
主要记录下typedef是如何从c生成汇编语言的

全局声明如下:

```
typdef int A;
A a;
```
生成未优化的代码:
```
# Code auto-generated by UCC
.data

.comm a,4
.text
```
```
## 词法分析
---
在keyword.h加入typedef关键词，token.h增加TK_TYPEDEF。

## 语法分析
---
decl.c:

.typedef 在语法分析阶段作为stgClass看待, int还是type specifier节点，解析int时设置seeTy=1表示已经有类型限定符了，否则A会作为TK_ID也在这个阶段被解析。 A是TK_ID应该解析在ParseDirectDeclarator; 

.lex.c的ParseDeclarationSpecifiers函数添加TK_TYPEDEF分支和TK_STATIC相同的处理。解析完后，通过CheckTypedefName函数将符号A添加到TypedefNames，用于保存typedef的新类型。之后碰到TK_ID就会通过IsTypedefName函数判断是否在TypedefNames的向量中

.A a;全局声明中的A在ParseDeclarationSpecifers作为TK_ID解析，因此添加TK_ID分支,创建AstTypedefName节点，成员id=A,设置seeTy=1

## 语义分析
---
declchk.c:

.typedef int A;生成的语法树节点NK_Token,在CheckDeclarationSpecifiers中主要给sclass赋值为TK_TYPEDEF,以及specs->ty=T(INT);然后在CheckGlobaDeclaration中根据sclass==TK_TYPEDEF进行CheckTypedef将符号A通过AddTypedefName加入到符号表中。

.A a;生成的语法节点时NK_TypedefName,在CheckDeclarationSpecifiers中根据节点的kind,获取符号表中的符号A,然后生成符号a的specs->ty=sym->ty;typedef作用到此结束，之后就是和int a;一样的中间代码生成和汇编代码生成

## 中间代码生成
---

## 汇编代码生成
---