# postfix []
---
简单记录[]运算符
```
void main()
{
    int arr[3][4];
    arr[1][2] = 5;
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $52, %esp
.BB0:
	leal -48(%ebp), %eax
    movl $5, -24(%ebp)
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
在decl.c的ParsePostfixDeclarator()添加TK_LBRACKET分支，创建Expression节点，设置节点op为OP_SIZEOF,然后递归调用ParseUnaryExpression函数解析
```
if (CurrentToken == TK_LBRACKET) {
    AstArrayDeclarator arrDec; 
    CREATE_AST_NODE(arrDec, ArrayDeclarator); // 创建ArrayDeclarator节点
    arrDec->dec = dec; // arr->dec指向arr(一维数组),[](二维数组)
    NEXT_TOKEN;
    if (CurrentToken != TK_LBRACKET) {
        arrDec->expr = ParseConstantExpression(); // 解析[3]和[4]
    }
    Expect(TK_RBRACKET);
    dec = (AstDeclarator)arrDec; 
    //         []
    //        /  \
    //      []    4
    //     /  \
    //   arr   3
}
```
expr.c解析 a[1][2] = 5;创建和声明相似的节点
```
    CREATE_AST_NODE(p, Expression);
    p->op = OP_INDEX;
    p->kids[0] = expr;
    NEXT_TOKEN;
    p->kids[1] = ParseExpression();
    Expect(TK_RBRACKET);
    expr = p;
    break;
    //              =(OP_EQUAL)
    //             /           \
    //          [] (OP_INDEX)  5(OP_CONST)
    //         /   \
    //(OP_INDEX)[]  2(OP_CONST)
    //       /  \ 
    //(OP_ID)arr 1(OP_CONST)
```

## 语义分析
---
在declchk.c添加 NK_ArrayDeclarator分支调用CheckArrayDeclarator()函数收集数组结点的类型信息，其结果存于创建的 struct typeDerivList 对象中，记录类型构造符为 ARRAY_OF(即数组)，记录数组的长度，指向下一个 declarator 结点的类型信息，最终构成一个由若干个 struct typeDerivList 对象构成的链表。最后在当前数组结点 astArrayDeclarator 中记录标识符的名称。

exprchk.c中的函数 ScalePointerOffset()，会根据数组 arr 的类型信息，把数组索引值 1 和 2 进行倍乘放大，进而得到 16 和 8.如下是未做FoldConstant的语法树:
```
    //            [] (OP_INDEX)
    //           /             \
    //(OP_INDEX)[]              OP_MUL
    //       /    \            /       \
    //(OP_ID)arr  OP_MUL   2(OP_CONST) 4(OP_CONST)
    //            /   \
    //  1(OP_CONST)  16(OP_CONST)
```

## 中间代码生成
---
TranslateArrayIndex()用于翻译数组索引，do 循环对常量偏移和可变偏移进行累加，分别存于 coff 和 voff 中，调用 TranslateExpression()来得到数组的首地址，调用 Offset()函数来产生访问数组元素的中间代码。

## 汇编代码生成
---

# 添加例子
```
int arr[3][4];
int *ptr1 = &arr[1][2];
```
## 语法分析
---
全局变量arr[3][4]，语法树和上面例子一样。

&arr[1][2]的语法树类似，根节点是&符号，左子树是arr[1][2]

## 语义检查
---
生成的DeriveList也是T(Aarray-4)->T(Array-3)->T(INT-arr).和Declaration Specifiers的type结合后符号arr的Type就是T(array-48)->T(array-16)->T(INT)


&arr[1][2] 先进入 CheckUnaryExpression 函数，然后check arr[1][2] 理所当然进入CheckPostfixExpression此时根节点为[]，左子树为[], 右子树为2，
然后递归CheckPostfixExpression，此时根节点为[], 左子树节点为arr, 右子树为1，最后CheckPrimaryExpression得到arr的Type：T(array-48)->T(array-16)->T(INT). Adjust调整左子树节点arr的Type为T(Pointer-48)->T(array-16)->T(INT),然后[]节点的Type=T(array-16)->T(INT), 右子树调用 ScalePointerOffset 生成新节点值为1\*16, 然后返回[]跳出CheckPostfixExpression递归，调整左子树[]的Type为T(Pointer-16)->T(INT), 然后根节点[]的Type=T(INT),右子树2继续调用 ScalePointerOffset 生成新节点值为2\*4. 返回根节点[]，继续执行CheckUnaryExpression函数, &节点的ty等于左子树[]节点的Type,根据左子树[]的op进入OP_INDEX分支，修改左子树op=OP_ADD,左子树Type=T(Pointer)->T(INT),最终返回的是[]节点。

CheckAddressConstant 检查是否为地址常量,根节点[]的op=OP_ADD,递归CheckAddressionConstant, 根节点[]的op=OP_INDEX,左子树为arr,右子树为16,进入while循环累加所有offset，最后部分生成新的节点[]，左子树为arr,右子树为offset。然后返回新建根节点。递归跳出后[]根节点的左子树为addr,右子树为8+16。最终返回[]节点，由initd->expr保存该节点

## 汇编代码生成
---
EmitGlobals 链表遍历所有全局声明符号(variableSymbol)，如果该符号的成员initd不为空，则生成init->expr代码,根据init->expr->op是否为op_ADD，生成。.long arr+40代码

# 例子
---
```
int arr[3][4];
typedef int (*ArrPtr)[4];
ArrPtr ptr = &arr[0];
int *ptr3 = &arr[1][2];
int *ptr1 = &arr[0][0];
int ** ptr2 = &ptr1;
void main()
{
    ptr[1][2] = 1;
}
```
## 语法分析
---
根节点[]的左子树[]，右子树2,左子树[]的左子树为[]，右子树为1，

## 语义分析
---
CheckPostfixExpression->CheckPostfixExpression->CheckPrimaryExpression,最终得到ptr的type为T(Pointer)->T(Array)->T(INT)。节点[]的type等于T(Pointer)->bty也就是T(Array)->T(INT), []的右子树的offset更新为1*16，返回到根节点[]，[]的type=T(INT),[]的右子树的offset更新为2*4=8,

## 中间代码生成
---
TranslateArrayIndex 类似CheckAddressConstant，统一把offset累加完，得到ptr节点和offset值。然后判断ptr是数组还是指针，

如果是指针，调用 Deref 解引用。先调用 Simplify(T(POINTER), ADD, (Symbol)p->val.p, IntConstant(coff)) 将 ptr 的地址movl到寄存器中,DST=ptr+offset,  GenerateAssign(T(Pointer), ADD, DST, SRC1, SRC2), DST:%eax, SRC1:ptr, SRC2:offset

tmp = CreateTemp(ty);
GenerateAssign(ty, tmp, DEREF, addr, NULL); //addr就是DST

## 汇编代码生成
---
EmitAssign 先调用 Move(X86_MOVI4, DST, SRC1); 生成 movl ptr, %eax, 再调用 PutASMCode(code, inst->opds); 生成addl 24, %eax,

EmitDeref 这行reg = PutInReg(SRC1); 生成movl (%eax), %ecx 取到地址，然后 movl $1, (%ecx)完成赋值

# 例子1
```
void main()
{
    arr[1][2] = 1;
}
```
符号arr的类型T(Array)->T(Array)->T(INT), 但是arr[1][2]表达式的Type是T(INT), isarray=0, 等式左边 dst=arr[24], 等式右边 src1 = 1, GenerateMove(ty, mov, dst, src);

# 例子2
```
void main()
{
    ptr2[0][0] = 5;
}
符号ptr2的类型T(Pointer)->T(Pointer)->T(INT), ptr2[0][0] 先将 ptr2 地址放到寄存器%eax, 然后addl offset %eax, 然后解引用 movl (%eax), %ecx, 然后IndirectMove, movl $5, (%ecx);

# 例子3
```
int arr[3][4][5][6];
int *ptr1 = &arr[0][0][0][0];
int ** ptr2 = &ptr1;
int *** ptr3 = &ptr2;
int **** ptr4 = &ptr3;
void main()
{
    ptr4[0][0][0][0] = 1;
}
```
1.符号ptr4的类型T(Pointer)->T(Pointer)->T(Pointer)->T(Pointer)->T(INT); 符号ptr3的类型 T(Pointer)->T(Pointer)->T(Pointer)->T(INT);

2.ptr[0][0][0][0]的语法树如下
```
                []
                /\
               [] 0
               /\
              [] 0
              /\
            []  0
            /\
        ptr4  0
```
在做语义检查的时候，一致递归到ptr4，获得ptr4的类型，返回第四层节点[]的类型T(Pointer)->T(Pointer)->T(Pointer)->T(INT)。判断 if (!expr->kids[0]->isarray && expr-ty->categ != ARRAY) 也就是说ptr4不是数组类型，ptr4[0]也不是数组类型，所以条件成立。构造出如下语法树:
```
        *(ty:T(Pointer)->T(Pointer)->T(Pointer)->T(INT))
       / \
      +(ty:T(Pointer)->T(Pointer)->T(Pointer)->T(Pointer)->T(INT))
     / \
  ptr4  0
```
最终语法树转换成如下:
```
                      *
                     / \
                    +   0
                   / \
                  *   0
                 / \
                +   0
               / \
              *   0
             / \
            +   0
           / \
          *   0
         / \
        +   0
       / \
    ptr4  0
```
然后中间代码生成递归Deref，生成汇编代码:
```
	movl ptr4, %eax
	movl (%eax), %ecx
	movl (%ecx), %eax
	movl (%eax), %edx
    mvol $1, (%edx)
```

# Wrong Example
```
int arr[4];
int *ptr = arr + 1; 
arr = 0; // expr lvalue = 0 so it will report The Left operand cannot be modified
sizeof(arr); // do not adjust arr to int* type
```