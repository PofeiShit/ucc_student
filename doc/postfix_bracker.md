# postfix []
---
简单记录[]运算符
```
void main()
{
    int arr[3][4];
    arr[1][2] = 5;
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $52, %esp
.BB0:
	leal -48(%ebp), %eax
    movl $5, -24(%ebp)
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
在decl.c的ParsePostfixDeclarator()添加TK_LBRACKET分支，创建Expression节点，设置节点op为OP_SIZEOF,然后递归调用ParseUnaryExpression函数解析
```
if (CurrentToken == TK_LBRACKET) {
    AstArrayDeclarator arrDec; 
    CREATE_AST_NODE(arrDec, ArrayDeclarator); // 创建ArrayDeclarator节点
    arrDec->dec = dec; // arr->dec指向arr(一维数组),[](二维数组)
    NEXT_TOKEN;
    if (CurrentToken != TK_LBRACKET) {
        arrDec->expr = ParseConstantExpression(); // 解析[3]和[4]
    }
    Expect(TK_RBRACKET);
    dec = (AstDeclarator)arrDec; 
    //         []
    //        /  \
    //      []    4
    //     /  \
    //   arr   3
}
```
expr.c解析 a[1][2] = 5;创建和声明相似的节点
```
    CREATE_AST_NODE(p, Expression);
    p->op = OP_INDEX;
    p->kids[0] = expr;
    NEXT_TOKEN;
    p->kids[1] = ParseExpression();
    Expect(TK_RBRACKET);
    expr = p;
    break;
    //              =(OP_EQUAL)
    //             /           \
    //          [] (OP_INDEX)  5(OP_CONST)
    //         /   \
    //(OP_INDEX)[]  2(OP_CONST)
    //       /  \ 
    //(OP_ID)arr 1(OP_CONST)
```

## 语义分析
---
在declchk.c添加 NK_ArrayDeclarator分支调用CheckArrayDeclarator()函数收集数组结点的类型信息，其结果存于创建的 struct typeDerivList 对象中，记录类型构造符为 ARRAY_OF(即数组)，记录数组的长度，指向下一个 declarator 结点的类型信息，最终构成一个由若干个 struct typeDerivList 对象构成的链表。最后在当前数组结点 astArrayDeclarator 中记录标识符的名称。

exprchk.c中的函数 ScalePointerOffset()，会根据数组 arr 的类型信息，把数组索引值 1 和 2 进行倍乘放大，进而得到 16 和 8.如下是未做FoldConstant的语法树:
```
    //            [] (OP_INDEX)
    //           /             \
    //(OP_INDEX)[]              OP_MUL
    //       /    \            /       \
    //(OP_ID)arr  OP_MUL   2(OP_CONST) 4(OP_CONST)
    //            /   \
    //  1(OP_CONST)  16(OP_CONST)
```

## 中间代码生成
---
TranslateArrayIndex()用于翻译数组索引，do 循环对常量偏移和可变偏移进行累加，分别存于 coff 和 voff 中，调用 TranslateExpression()来得到数组的首地址，调用 Offset()函数来产生访问数组元素的中间代码。

## 汇编代码生成
---
