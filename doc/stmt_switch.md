# Switch

switch语句是如何生成汇编的
```
void main()
{   
    int a, b;
    switch(a) {
        case 1:
            a = 30;
            break;
        case 2:
            a = 4;
            break;
        case 50:
            a = 9;
            break;
        case 2000:
            a = 10;
            break;
    }
    a = 6;
}
```
未优化的汇编代码:
```
# Code auto-generated by UCC
.data
.text
.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $12, %esp
.BB0:
	cmpl $50, -4(%ebp)
	jl .BB4
.BB1:
	cmpl $50, -4(%ebp)
	jg .BB8
.BB2:
	jmp .BB15
.BB3:
.BB4:
	cmpl $1, -4(%ebp)
	jl .BB19
.BB5:
	cmpl $2, -4(%ebp)
	jg .BB19
.BB6:
	movl -4(%ebp), %eax
	subl $1, %eax

.data

swtchTable1:	.long	.BB11
           	.long	.BB13
           	
.text

	jmp *swtchTable1(,%eax,4)
.BB7:
.BB8:
	cmpl $2000, -4(%ebp)
	jne .BB19
.BB9:
	jmp .BB17
.BB10:
.BB11:
	movl $30, -4(%ebp)
	jmp .BB19
.BB12:
.BB13:
	movl $4, -4(%ebp)
	jmp .BB19
.BB14:
.BB15:
	movl $9, -4(%ebp)
	jmp .BB19
.BB16:
.BB17:
	movl $10, -4(%ebp)
	jmp .BB19
.BB18:
.BB19:
	movl $6, -4(%ebp)
.BB20:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 词法分析
---
在keyword.h加入switch,case,default关键词，token.h增加TK_SWITCH, TK_CASE, TK_DEFAULT。

## 语法分析
---
stmt.c：

.在ParseStatement添加TK_CASE,TK_DEFAULT,TK_SWITCH分支分别调用ParseCaseStatemetn,ParseDefautl,ParseSwitchStatement函数.

## 语义分析
---
stmtchk:

.在Stmtcheckers函数指针数组中添加CheckSwitchStatement,CheckCaseStatement,CheckDefaultStatement函数指针。

CheckCaseStatement:

.取CURRENTF->switches的栈顶元素，如果为空，则说明该 case 语句没有出现在switch语句中而报错。调用函数 CheckConstantExpression()来检查一下case 语句中出现的表达式是否为编译时的常量，即产生式中的 constant-expression，接着递归地调用 CheckStatement()来对产生式中的 statement 进行语义检查，最后整个 case 语句加入到相应的 switch 语句中，以便于后续的中间代码生成。

CheckDefaultStatement:

.函数 CheckDefaultStatement 用于对 default 语句进行语义检查，检查一下 CURRENTF->swtches 的栈顶是否为空。由于一个switch语句中，只能有一个 default 语句，我们需要检查一下之前是否已有 default 语句。

## 中间代码生成
---
.struct astCaseStatement 描述一条case语句，其中的next域用于记录case语句在源代码中出现的先后顺序，nextCase域用于给case语句表达式数值从小到大排序。

.为了描述“段”的概念，引入了 switchBucket 结构体，Bucket是“桶”的意思，用“Bucket”来存放处于同一段中的各条 case 语句。每个段对应一个桶，多个桶构成了一条链表。而每个桶内又可包含多条 case 语句，这些case语句又可构成 一条链表，switchBucket 结构体如下所示:
```
typedef struct switchBucket{    //用于描述形如{0，1，4}这样的段
    int ncase;                  //桶内case语句的条数，例如3
    int minVal;                 //桶内 case 语句表达式的最小值，例如 0 
    int maxVal;                 //桶内 case 语句表达式的最大值，例如4 
    AstCaseStatement case;      //桶内 case 语句链表的链首 
    AstCaseStatement *tail;     //指向链尾，便于插入操作 
    struct switchBucket *prev;  //用于组成由各个“桶”对象构成的链
} *SwitchBucket;
```
.为了方便对各 SwitchBucket 进行二分查找，除了把各 switchBucket 对象通过上述 prev 域构成一条链表外，还会用一个数组来存放各 switchBucket 的首地址.

.Switch语句的翻译:

.先翻译 switch 语句中的表达式。下面代码把case语句加入到相应的桶中，
```
	while (p) {
		q = p;
		p = p->nextCase;
		q->respBB = CreateBBlock(); //由于每个case语句都是控制流的跳转目标，因此每个case语句都对应一个基本块，这行创建了这些基本块
		val = q->expr->val.i[0];
		if (bucket && (bucket->ncase + 1) * 2 > (val - bucket->minVal)) { // 用于判断“当前桶中的 case 语句密度是否大于 1/2”
			bucket->ncase++;
			bucket->maxVal = val;
			*bucket->tail = q;
			bucket->tail = &(q->nextCase);
            //调用 MergeSwitchBucket()函数进行相邻桶的合并，由此可把{0，1，4}和{9，10，11}这两个桶合并为{0，1，4，9，10，11}
			switchStmt->nbucket -= MergeSwitchBucket(&bucket);
		} else {
            //当 Case 语句密度小于或等于 1/2 时，创建一个新桶
			ALLOC(b);
			b->cases = q;
			b->ncase = 1;
			b->minVal = b->maxVal = 1;
			b->tail = &(q->nextCase);
			b->prev = bucket;
			bucket = b;
			switchStmt->nbucket++;
		}
	}
	switchStmt->buckets = bucket;
    // 用于创建桶指针数组，便于进行二分查找
	bucketArray = HeapAllocate(CurrentHeap, switchStmt->nbucket * sizeof(SwitchBucket));
	for (i = switchStmt->nbucket - 1; i >= 0; i--) {
		bucketArray[i] = bucket;
		*bucket->tail = NULL;
		bucket = bucket->prev;
	}
    // 当 Switch 语句的表达式的值不与任何 case 匹配时，
	switchStmt->defBB = CreateBBlock();
    // 控制流要么进入default语句(在 C 程序员提供 default 语句时)，
	if (switchStmt->defStmt) {
		switchStmt->defStmt->respBB = switchStmt->defBB;
		switchStmt->nextBB = CreateBBlock();
	} else {
        // 要么跳出switch语句(在 C 程序员没有编写 default 语句时)
		switchStmt->nextBB = switchStmt->defBB;
	}
    // 调用 TranslateSwitchBuckets() 函数，产生用于比较和跳转的中间代码
	TranslateSwitchBuckets(bucketArray, 0, switchStmt->nbucket - 1, sym, NULL, switchStmt->defBB);
    // 如果 switch 语句确实包含 case 或者 default 语句
	if (switchStmt->cases != NULL || switchStmt->defStmt != NULL) {
        // 递归地调用 TranslateStatement()函数，翻译候选式“switch(expr) statement”中的 statement
		TranslateStatement(switchStmt->stmt);
	}
	StartBBlock(switchStmt->nextBB);
```
```
static int MergeSwitchBucket(SwitchBucket *pBucket)
{
	SwitchBucket bucket = *pBucket;
	int count = 0;
	while (bucket->prev) {
        // 前一个桶{0,1,4}和当前桶{9, 10, 11}如果合并,3+
		if ((bucket->prev->ncase + bucket->ncase + 1) * 2 <= (bucket->maxVal - bucket->minVal))
			break;
        // 当前桶合并到前一个桶，更新前一个桶的case语句数量
		bucket->prev->ncase += bucket->ncase;
        // 更新前一个桶的maxVal
		bucket->prev->maxVal = bucket->maxVal;
        // 更新前一个桶的case链尾
		*bucket->prev->tail = bucket->cases;
        // 更新前一个桶的case链尾指针
		bucket->prev->tail = bucket->tail;
        // {0,1,4}和{9,10,11}合并后，bucket->prev指向新合并的{0,1,4,9,10,11}的尾部
		bucket = bucket->prev;
		count++;
	}
    // 更新指向合并后的桶的指针
	*pBucket = bucket;
	return count;
}
```
.主要就是TranslateSwitchBuckets函数
```
static void TranslateSwitchBuckets(
    //对 bucketArray[left]至 bucketArray[right]这几个桶进行处理 
    SwitchBucket *bucketArray, int left, int right, 
    //符号 choice 代表了 switch(expr) statement 中表达式的值
    Symbol choice,
    //指向当前要处理的 SwichBucket 桶或者为 NULL
    BBlock currBB,
    //参数 defBB 要么是 default 语句对应的基本块(存在 default 语句时) 
    //要么是 switch 语句之后的基本块 nextBB(当 default 语句不存在时)
    BBlock defBB,
); 

static void TranslateSwitchBuckets(SwitchBucket *bucketArray, int left, int right, Symbol choice, BBlock currBB, BBlock defBB)
{
	int mid, len, i;
	AstCaseStatement p;
	BBlock lhalfBB, rhalfBB;
	BBlock *dstBBs;
	Symbol index;
	if (left > right)
		return;
	mid = (left + right) / 2;

	lhalfBB = (left > mid - 1) ? defBB : CreateBBlock();
	rhalfBB = (mid + 1 > right) ? defBB : CreateBBlock();
    // 构造长度为len的跳转表
	len = bucketArray[mid]->maxVal - bucketArray[mid]->minVal + 1;
	dstBBs = HeapAllocate(CurrentHeap, (len + 1) * sizeof(BBlock));
    // 对跳转表进行初始化,从而得到形如“(BB11,BB13,)”的表格
	for (i = 0; i < len; ++i) {
		dstBBs[i] = defBB;
	}
	dstBBs[len] = NULL;

	p = bucketArray[mid]->cases;
	while (p) {
		i = p->expr->val.i[0] - bucketArray[mid]->minVal;
		dstBBs[i] = p->respBB; // 每个case对应的BBlock
		p = p->nextCase;
	}
	if (currBB != NULL) {
		StartBBlock(currBB);
	}
    if(len == 1 && lhalfBB == rhalfBB){	
        // 当桶中只有一个 case 语句，且该桶左侧或右侧的其他桶都已被处理完，
        // 例如当我们处理桶{20000}时，我们产生一条比较指令 “if (a != 20000) goto BB19;”
        GenerateBranch(choice->ty, lhalfBB, JNE, choice, IntConstant(bucketArray[mid]->minVal));
    }else{
        // 而当我们面对{50}或{1,2}时，则产生形如“if (a < 50) goto BB4; BB1: if (a > 50) goto BB8;”这样的中间代码。
        GenerateBranch(choice->ty, lhalfBB, JL, choice, IntConstant(bucketArray[mid]->minVal));

        StartBBlock(CreateBBlock());
        GenerateBranch(choice->ty, rhalfBB, JG, choice, IntConstant(bucketArray[mid]->maxVal));	 
    }
    // 用于产生跳入相应 case 语句的代码,例如跳入 case 50的指令“BB2: goto BB17;”
	StartBBlock(CreateBBlock());
    // 当桶内 case 个数大于 1 时，通过跳转表进行跳转
    // 例如为桶{1,2}产生以下跳转代码:
    // BB6:
    //    t0 : a - 1;
    //    goto (BB11,BB13,)[t0]; //跳往case 1或case 2
	if (len != 1)
	{		
		index = CreateTemp(choice->ty);
		GenerateAssign(choice->ty, index, SUB, choice, IntConstant(bucketArray[mid]->minVal));
		GenerateIndirectJump(dstBBs, len, index);
	}
	else
	{
        //当跳转表的大小为 1 时，我们只有一个跳转目标，产生一条无条件跳转指令即可
		GenerateJump(dstBBs[0]);
	}
	StartBBlock(CreateBBlock());
    // 递归地调用TranslateSwitchBuckets()，对位于当前桶的左侧的各个桶进行处理，
	TranslateSwitchBuckets(bucketArray, left, mid - 1, choice, lhalfBB, defBB);
    // 递归地对右侧各桶进行翻译
	TranslateSwitchBuckets(bucketArray, mid + 1, right, choice, rhalfBB, defBB);
}
```

以{{1, 2}, {50}, {2000}}为例子,讲解比较和跳转生成过程呢
left = 0, right = 2;
mid = 1;
lhalfBB = CreateBBlock(); //(0 !> 0)
rhalfBB = CreateBBlock(); //(2 !> 2)
len = 50 - 50 + 1;
p = bucketArray[1]->cases
while (p) {
    i = 5 - 5 = 0
    dstBBs[0] = p->resBB;
    p = p->nextCase (p is NULL)
}
产生 if (a < 50) goto BB4
GenerateBranch(choice->ty, lhalfBB, JL, choice, IntConstant(bucketArray[mid]->minVal));

StartBBlock(CreateBBlock()); // .BB1
产生 if (a > 50) goto BB8
GenerateBranch(choice->ty, rhalfBB, JG, choice, IntConstant(bucketArray[mid]->maxVal));	 
StartBBlock(CreateBBlock()); // .BB2
//当跳转表的大小为 1 时，我们只有一个跳转目标，产生一条无条件跳转指令即可
GenerateJump(dstBBs[0]); // goto BB17

// 
StartBBlock(CreateBBlock()); // .BB3
// 递归地调用TranslateSwitchBuckets()，对位于当前桶的左侧的各个桶进行处理，
++++TranslateSwitchBuckets(bucketArray, left, mid - 1, choice, lhalfBB, defBB);
{1, 2}
left = 0, right = 0
mid = 0
lhalfBB = defBB; (0 > -1)
rhalfBB = defBB; (1 > 0)
len = (2 - 1) + 1
p = bucketArray[0]->cases;

    i = 1 - 1;
    dstBBs[0] = p->respBB;
    i = 2 - 1;
    dstBBs[1] = p->resBB;
StartBBlock(currBB); // .BB4

// if (a < 1) goto BB19
GenerateBranch(choice->ty, lhalfBB, JL, choice, IntConstant(bucketArray[mid]->minVal));

StartBBlock(CreateBBlock()); // .BB5
// if (a > 2) goto BB19
GenerateBranch(choice->ty, rhalfBB, JG, choice, IntConstant(bucketArray[mid]->maxVal));	 

// BB6
StartBBlock(CreateBBlock());

    // 当桶内 case 个数大于 1 时，通过跳转表进行跳转
    // 例如为桶{1,2}产生以下跳转代码:
    // BB6:
    //    t0 : a - 1;
    //    goto (BB11,BB13,)[t0]; //跳往case 1或case 2
    if (len != 1)
    {		
        index = CreateTemp(choice->ty);
        // t0 : a - 1; choice=a, bucketArray[0]->minVal=1
        GenerateAssign(choice->ty, index, SUB, choice, IntConstant(bucketArray[mid]->minVal));
        // goto (BB11, BB13, )[t0]
        GenerateIndirectJump(dstBBs, len, index);
    }
// BB7
StartBBlock(CreateBBlock());
// left = 0 mid = -1
TranslateSwitchBuckets(bucketArray, left, mid - 1, choice, lhalfBB, defBB);
// mid = 1, right = 0
TranslateSwitchBuckets(bucketArray, mid + 1, right, choice, rhalfBB, defBB);
++++跳出左递归
进入右递归:
////////////////////////////
TranslateSwitchBuckets(bucketArray, mid + 1, right, choice, rhalfBB, defBB);
mid+1: 2 right : 2
{2000}
left = 2, right = 2
mid = 2
lhalfBB = defBB; (2 > 1)
rhalfBB = defBB; (3 > 2)
len = 2000 - 2000 + 1
i = 2000 - 2000
dstBBs[0] = p->respBB
// BB8
if (currBB != NULL) {
    StartBBlock(currBB);
}
// if (a != 20000) goto BB19
if(len == 1 && lhalfBB == rhalfBB){	
    // 当桶中只有一个 case 语句，且该桶左侧或右侧的其他桶都已被处理完，
    // 例如当我们处理桶{20000}时，我们产生一条比较指令 “if (a != 20000) goto BB19;”
    GenerateBranch(choice->ty, lhalfBB, JNE, choice, IntConstant(bucketArray[mid]->minVal));
}
// BB9
StartBBlock(CreateBBlock());

//当跳转表的大小为 1 时，我们只有一个跳转目标，产生一条无条件跳转指令即可 
// goto BB15
GenerateJump(dstBBs[0]);

// BB10
StartBBlock(CreateBBlock());
left : 2, mid - 1 : 1
TranslateSwitchBuckets(bucketArray, left, mid - 1, choice, lhalfBB, defBB);
mid + 1 : 3 right : 2
TranslateSwitchBuckets(bucketArray, mid + 1, right, choice, rhalfBB, defBB);
// 
////////////////////////////
到这里就是TranslateSwitchBuckets生成的中间代码

之后就是翻译Switch之后的复杂语句
TranslateCompoundStatement: 循环调用TranslateStatement(stmt),根据stmt的kind，翻译case语句或者break语句

case语句
```
static void TranslateCaseStatement(AstStatement stmt)
{
	AstCaseStatement caseStmt = AsCase(stmt);
    // BB11 case 1
	StartBBlock(caseStmt->respBB);
    // 翻译case条件内的语句 a = 30
    // a = 4
	TranslateStatement(caseStmt->stmt);
}
```
break语句
```
static void TranslateBreakStatement(AstStatement stmt)
{
	AstBreakStatement brkStmt = AsBreak(stmt);
	if (brkStmt->target->kind == NK_SwitchStatement)
        // jump的目的是switchStmt保存的nextBB
		GenerateJump(AsSwitch(brkStmt->target)->nextBB);
	else
		GenerateJump(AsLoop(brkStmt->target)->nextBB);
    // BB12
	StartBBlock(CreateBBlock());
}
```

## 汇编代码生成
---
```
static void EmitIndirectJump(IRInst inst)
{
	BBlock *p;
	Symbol swtch;
	int len;
	Symbol reg;
	p = (BBlock*)DST;
    // 调用 PutInReg()函数把操作数SRC1(保存的case语句的索引)加载到寄存器中
	reg = PutInReg(SRC1);
	PutString("\n");
    // 用于产生“.data”，表示接下来的内容为数据区
	Segment(DATA);
    // 接着创建一个名称形如“swtchTable1” 的符号对象
	CALLOC(swtch);
	swtch->kind = SK_Variable;
	swtch->ty = T(POINTER);
	swtch->name = FormatName("swtchTable%d", SwitchTableNum++);
	swtch->sclass = TK_STATIC;
	swtch->level = 0;
    // 会在数据区中创建跳转表
    /************************************
    swtchTable1: .long .BB4
                .long .BB5
                .long .BB6
    *************************************/
	DefineGlobal(swtch);
	DST = swtch;
	len = strlen(DST->aname);
	while (*p != NULL) {
        // 生成.long .BB4
		DefineAddress((*p)->sym);
		PutString("\n");
		LeftAlign(ASMFile, len);
		PutString("\t");
		p++;
	}
	PutString("\n");
    // 输出“.text”，表示接下来的内容为代码区
	Segment(CODE);
    // 因为已经把SRC1加载到寄存器reg中，所以我们就可在汇编指令中使用该寄存器的名称
    // 为此我们把中间指令里的 SRC1 改为相应的寄存器
	SRC1 = reg;
    // 调用 ClearRegs()对 x86 CPU 中的寄存器进行了必要的回写
	ClearRegs();
    // 调用 PutASMCode()产生了形如“jmp *swtchTable1(,%eax,4)”的汇编指令, swtchTable1+%eax*4
	PutASMCode(X86_IJMP, inst->opds);

}
```
指令jmp *%rax用寄存器%rax中的值作为跳转目标。
指令jmp *(%rax)以%rax中的值作为读地址，从内存中读出跳转目标。