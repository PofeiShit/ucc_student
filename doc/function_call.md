# function call
函数调用是如何生成汇编代码的
```
int print_hw(int a, char b)
{
    return 0;
}
int main()
{
    print_hw(3, 'a');
    return 1;
}

```
生成未优化的汇编代码:
```
# Code auto-generated by UCC
.data

.text

.globl	print_hw

print_hw:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
.BB0:
	movl $0, %eax
	jmp .BB2
.BB1:
.BB2:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $4, %esp
.BB3:
	pushl $97
	pushl $3
	call print_hw
	addl $8, %esp
	movl $1, %eax
	jmp .BB5
.BB4:
.BB5:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 词法分析
---
没有新增，忽略
## 语法分析
---
.定义部分忽略，在function_definition.md介绍过了，print_hw跳过，重点介绍main调用print_hw函数

.print_hw(3, 'a');就是个表达式语句，从stmt的exprssionStmt进入expr, primary分析了print_hw和参数，在PostFixeExpressoin将两个作为子节点连接起来

.语法分析完毕

## 语义分析
---
.老地方checkFunction, 三步走：先根据declarationSpecifier和Declarator生成类型， 第二步创建main和参数符号，第三步check函数体{}

.然后进入函数体，语法分析也说了从stmt的expressionStmt进入expr，语义分析同样的走法，从checkstmt的CheckExpressionStm进入CheckExpr，stmt就是个工具

.分析checkExpression,直接有CheckFunctionCall对应检查，语法树走下来，左子节点必然是print_hw符号，碰到符号去符号表查找了，

    .找不到就报错咯，所以被调函数要写在调用函数之前或者被调函数写个声明，总之就是为了产生个符号，在编译节点把编译器糊弄过去，但是如果链接还没有这个符号对应的代码就会报ld error了

    .找到的话，就把这个符号记录type赋值给 当前左子节点print_hw的type，然后调整当前的type, 函数调用直接当成指针调用

.checkArgument:参数个数和类型对齐

.确定函数调用整个表达的type(就是经常写的返回类型int，上面check的时候调整类型啥的，包裹了好几层:（int) -> (FuctionType) -> (PointerType))


## 中间代码生成
---
.也是老地方TransFunction, 三步走：生成entryBB和exitBB， 第二步：对函数体{}生成Basic Block, 第三步：生成label名

.中间代码生成同样， 从transStmt的TranslateExpressionStatement进入transExpr, 老工具了

.函数调用的中间代码组成 [CALL 返回符号 函数调用符号  函数参数符号] 也就是多了个Call指令，其他格式和c语言写起来一样一样的

.返回符号就是语义分析最后的type，但是这个是SK_Temp类型的

.函数调用符号直接使用语义分析的

.函数参数类型:和return章节一样，整数在中间代码才创建符号

## 汇编代码生成
---
.还是老地方EmitFunction (编译器也就这么几个主要函数，整体框架还是很清楚的，剩下的就是亿点点细节) 还是三步走:EmtiPrologue生成老头部，入参：函数要分配多大的临时变量和局部变量的大小stksize,且给每个上述符号计算相对于ebp的offset，第二步：EmitBBlock, 第三步EmitEpilogue

.来看第二步EmitBBlock的EmitCall,  先Push_Argument把参数入栈，然后把eax,ecx,edx寄存器里的值保存好，也就是调用者首问责任制。然后生成Call print_hw汇编语言，参数入栈的大小要收回，然后最后一步需要把函数返回值从eax寄存器取出来,放到变量中,比如int a = add(3, 4); 根据之前return知道最后的返回值是放到eax寄存器中的，那么现在当然要从eax取了，但是，像print_hw这种情况，没有定义变量来接受咋办了，从eax取了，但是没有完全取。放心，之前有说啊，print_hw的返回符号是SK_temp,编译器针对SK_temp都是要给它分配寄存器的啊，这里就是分配eax，然后判断eax和返回的eax一样，好巧啊，所以就直接跳过了。over

.以上函数调用完成