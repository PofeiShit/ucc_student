# conditional operator
记录下条件操作符生成汇编
```
void main()
{
    int a;
    a ? 3 : 2;
}

```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	cmpl $0, -4(%ebp)
	jne .BB3
.BB1:
	jmp .BB3
.BB2:
	movl $0, -8(%ebp)
	jmp .BB4
.BB3:
	movl $1, -8(%ebp)
.BB4:
.BB5:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret
```
## 语法分析
---
ParseConditionalExpression: 调用ParseBinaryExpression时的参数 Prec[OP_OR]指明了“逻辑或||”运算符的优先级,创建了子表达式a对应的节点，op域为OP_QUESTION的节点，CREATE_AST_NODE(condExpr->kids[1], Expression);构建了op域为OP_COLON的结点，子表达式3由ParseExpression所创建，而子表达式2由ParseConditionalExpression()所创建

## 语义分析
---
先对第一个操作数a进行语义检查，然后递归的调用CheckExpression()函数对3，2进行语义检查，如果都为算术类型，整个条件表达式的类型为3和2的公共类型

## 中间代码生成
---
a ? 3 : 2
按a照逻辑如下:
```
BB0:
    if (a) goto trueBB
falseBB:
    t = 2
    goto nextBB
trueBB:
    t = 3
nextBB:
```
按照!a的逻辑
```
BB0:
    if (!a) goto falseBB
trueBB:
    t = 3
    goto nextBB
falseBB:
    t = 2
nextBB:
```
两种写法都可以采取

## 汇编代码生成
---
略