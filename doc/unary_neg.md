# unary +/-
---
简单记录+/-运算符
```
void main()
{
    int a;
    +a;
    -a;
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	movl -4(%ebp), %eax
	notl %eax
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
在expr.c添加ParseUnaryExpression()添加TK_ADD和TK_SUB，共享TK_INC分支

## 语义分析
---
在exprchk.c添加 CheckUnaryExpression()添加OP_POS和OP_NEG分支调用CheckExpression()检查变量a, 根据expr->op == OP_POS ? expr->kids[0] : FoldConstant(expr); +a即返回a;

## 中间代码生成
---
在transexpr.c的TranslateUnaryExpression函数和OP_COMP共享分支,调用Simplify翻译"~a"/"-a",做一些编译时的代数简化，根据OPMap找到OP_NOT对应中间代码指令为NEG."+a"在这一步因为expr->op为OP_ID直接return NULL;不生成汇编代码

## 汇编代码生成
---
-运算符有专门的汇编指令negl对应，根据opcode.h知道NEG对应的func是Assign
处理“DST: -SRC1”的一元运算，不必为 SRC2 分配寄存器，AllocateReg(inst, 1)也会因为src1是SK_Variable条件并不分配寄存器
movl -4(%ebp), %eax
negl %eax