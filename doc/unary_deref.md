# unary *
---
简单记录*运算符
```
void main()
{
    int *a;
    *a;
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	movl -4(%ebp), %eax;
    movl (%eax), %ecx;
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
首先要支持单目运算符*，声明的时候要添加指针，decl.c在ParseDeclarator先解析*符号，创建ptrDeclarator节点，dec成员是递归调用ParseDeclarator的结果，因为会有如下这种声明 int *******a; 解析完前面一大堆*，然后再调用PostfixExpression()解析a之后的
在expr.c中在老地方添加TK_MUL分支即可

## 语义分析
---
先在declchk.c检查int *a;的声明，完成符号创建和类型确认即可。
在exprchk.c添加 CheckUnaryExpression()添加OP_DEREF分支调用CheckExpression()从符号表中获得变量a的ty，赋值给表达式*a的ty

## 中间代码生成
---
在TransUnaryExpression函数中添加OP_DEREF分支,然后调用Deref(expr->ty, src);之后再调用	GenerateAssign(ty, tmp, DEREF, addr, NULL);生成中间代码指令。

## 汇编代码生成
---
EmitDeref()函数用来处理形如“t2: *ptr”的中间指令，对应的四元式为<DEREF, t2, ptr, NULL>,  PutInReg先把ptr加载到寄存器中，不妨设其为eax
之后两行会把中间指令<DEREF, t2, ptr, NULL>改为<MOV，t2，(%eax)， NULL>，之后通过EmitMove()函数产生以下汇编代码:
movl (%eax), %ecx ; //临时变量t2对应的寄存器为ecx

# deref 例子补充
---
```
int *ptr1;
int **ptr2 = &ptr1;
```
## 语法分析
---
等号左边 *->*->ptr2 语法树， 等号右边 &->ptr1语法树

## 语义分析
---
符号ptr1的Type为T(Pointer)->T(INT);
符号ptr2的Type为T(Pointer)->T(Pointer)->T(INT); 等号右边调用CheckUnaryExpression，检查左子树节点ptr1，获取其Type，&节点的type为ptr1的bty，也就是T(INT)。因为是取地址的符号,最后再生成指针类型:expr->ty = PointerTo(ty);

CheckAddressConstant 函数统一将根节点op调整为op_ADD, 左子树为地址，右子树为offset。用于EmitGlobals生成.long base_address + offset格式