# if

if语句是如何生成汇编的
```
int main()
{
    int a;
    if (a == 1) {
        a = 2;
    } else {
        a = 3;
    }
}
```
未优化的汇编代码:
```
# Code auto-generated by UCC

.data
.text
.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
    subl -4, %ebp
.BB0:
    cmp $1, -4(%ebp)
    jne .BB2
.BB1:
    movl $2, -4(%ebp)
    jmp .BB3
.BB2:
    movl $3, -4(%ebp)
.BB3:
.BB4:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret
```

## 词法分析
---
在keyword.h加入if和else关键词，token.h增加TK_IF, TK_ELSE。

## 语法分析
---
stmt.c：

.在ParseStatement添加TK_IF分支调用ParseIfStatement函数解析if语句.

. a == 1对应ifStmt->expr节点。a = 2对应ifStmt->thenStmt节点。a = 3对应ifStmt->elseStmt节点

## 语义分析
---
stmtchk:

.在Stmtcheckers函数指针数组中添加CheckIfStatement函数指针和CheckLocalStatement函数指针，分别check if语句和复合语句的语义，复合语句的左大括号表示了一个新的作用域的开始，我们需要创建新的符号表来存放在该作用域中声明的符号。调用的EnterScope函数中完成了创建新符号表的工作。


## 中间代码生成
---
在使用函数 TranslateBranch(expr, bt, bn)时，有这么 两个约定:
(1) 当 expr 为真时，跳往 bt 基本块;
(2) 紧随“函数 TranslateBranch()所生成的跳转指令”之后的基本块为 bn。

翻译“if(expr) stmt”，我们需要创建 trueBB 和 nextBB 这两个基本块;
```
if(expr)
    stmt
is translated into:

    if ! expr goto nextBB
trueBB:
    stmt
nextBB:

.如果直接翻译if expr goto trueBB会导致必然到trueBB或者增加更多的指令
1. 必然到trueBB
    if expr goto trueBB
trueBB:
    stmt
2. 增加更多中间指令
    if expr goto trueBB
nextBB:
    jmp BB
trueBB:
    stmt
    jmp nextBB
BB:
    xxxx
```
翻译“if(expr) stmt1 else stmt2”语句，我们需要创建 trueBB、falseBB 和 nextBB 这 3 个基本块。
```
if (expr)
    stmt1
else 
    stmt2
is translated into:

    if ! expr goto falseBB
trueBB:
    stmt1
    jmp nextBB
falseBB:
    stmt2
nextBB:

```

## 汇编代码生成
---