# unary ->
---
简单记录.运算符
```
struct test
{
    int a;
};
void main()
{
    struct test *p;
    p->a = 10;
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	leal -4(%ebp), %eax
	movl $1, -4(%ebp)
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
在expr.c的ParsePostfixExpression()添加TK_POINTER分支和TK_DOT共用

创建Expression节点，设置节点op为OP_PTR_MEMBER,可以确定->操作符后面是a,所以直接赋值给p->val='a'

## 语义分析
---
1.在exprchk.c的CheckPostfixExpression()添加OP_PTR_MEMBER分支，分支调用 CheckMemberAccess()进行语义检查，
在表达式 p->a 中，p 和 a 相当于是 运算符->的两个操作数，dt 对应语法树结点的类型应是记录类型
expr->kids[0] = CheckExpression(expr->kids[0]);对成员选择运算符的左操作数进行语义检查

2.LookupField()检查一下结构体 p 中是否有名字为 a 的域成员, 如果在结构体的定义中找不到成员 a，则说明 dt->a 是非法的表达式

3.最后把查询得到的关于域成员 a 的类型信息，通过expr->val.p = fld存放到 dt->a 表达式对应的语法树结点上。 结构体 struct filed 描述了域成员的相关信息

4.在语义检查后，域成员a在结构体struct test中的偏移量等信息由struct filed对象保存即expr->val.p = fld;而结构体对象test对应的符号则由 struct symbol 对象来存放.

5.整个CheckMemberAccess就是检查p->a表达式。

## 中间代码生成
---
当我们面对“p->a = 30;”时，UCC 编译器为p->a产生的中间代码如下所示，
```
t5: p
t6: t5 + 0; //成员a的偏移为0
t7: *t6;
```
由于t7是个临时变量，如果对t7进行赋值，则p->a的值并没有发生变化。我们要对t6所指向的内存单元进行赋值，才能改变p->a的值。
此时我们可产生形如“(IMOV, t6,30);”的中间代码，其中IMOV表示把30赋值给t6所指向的内存单元，而不是把30赋值给t6。UCC编译器的GenerateIndirectMove()函数用于产生IMOV指令。若t6的值存放在寄存器eax中，则最终生成的汇编代码可以是“movl $30, (%eax)”，对应的中间代码可表示为:*t6 = 30; //而不是 t6 = 30;

1.TranslatePostfixExpression添加OP_PTR_MEMBER分支,在分支中调用TranslateMemberAccess函数生成中间代码

2.在TranslateMemberAccess函数中添加expr->op==OP_PTR_MEMBER的条件用于计算“形如 p->a 的结构体成员”的基地址和常量偏移
```
    fld = p->val.p;
    coff = fld->offset;
    tmp = TranslateExpression(expr->kids[0]);  // tmp就是基地址
```

3.Offset函数：调用Deref来产生，Deref 是 Dereference 的缩写，表示“提领操作”，也有译为“解引用”，实际上进行的操作是“间接寻址”。

4.Deref()主要用来生成一条形如“t3:\*t2” 的间接寻址指令，其中t2中存放一个地址，\*t2表示取“这个地址对应内存单元中的内容”，并把该内容存于临时变量t3中，符号t3就作为“间接寻址”的结果返回.

5.Offset返回的就是符号a，实际上TranslateMemberAccess返回就是p->a或者p->b对应的域成员的符号，但是这里先稍作修改，当是PTR_MEMBER就返回基地址
生成完p->a,接着生成=1赋值表达式

TranslateAssignmentExpression根据expr->op==PTR_MEMBER生成IndirectMove中间指令
通过GenerateIndirectMove(expr->ty, dst, src);产生一条 IMOV 指令(形如“*t = val;”)来实现赋值.这里的dst其实t6
，这需要进行dst=Deref(expr->ty, dst)间接寻址。

## 汇编代码生成
---
EmitIndirectMove:
```
static void EmitIndirectMove(IRInst inst)
{
	Symbol reg;
    //把DST保存的地址放到某个寄存器中。假如%eax
	reg = PutInReg(DST);
	inst->opcode = MOV;
    // DST:(%eax) 通过()间接求得地址,然后将number赋值给(%eax)
	DST = reg->next;
    // src:10
    // 中间指令<MOV,(%eax),number,NULL> 对应（%eax) = number
	EmitMove(inst);
}
```
