# return

return语句是如何生成汇编的
```
int main()
{
    return 0;
}
```
未优化的汇编代码:
```
# Code auto-generated by UCC

.data
.text
.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
.BB0:
	movl $0, %eax
	jmp .BB2
.BB1:
.BB2:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret
```

## 词法分析

    .token.h和keyword.h添加return

## 语法分析

    .return;语句添加在函数体内，语法分析改动在ParseStatement根据Return选择ReturnStatement,然后因为return可以返回表达式，所以需要ParseExpression
    .ParseExpression递归分析ParsePrimaryExpression解析“1“
    .语法分析完毕，相对于之前的函数定义解析，返回的astFunction的stmt增加了亿点点内容

## 语义分析

    .老套路，从CheckFunction开始之前的添加main符号不变，多了checkStatement
    .以及check return对应的表达式,但是目前假设写的代码没有错误，所以retStmt对应的expression可以不用检查，其实如果不生成类型系统或者添加符号，其他的代码可以不用关注，都是一些检查错误：类型兼容，不符合语义等等

## 中间代码生成

    .从TransFunction开始，中间调用TransStmt对return进行转换
    .return语句转换先生成expressio对应的中间代码， 然后生成return跳转
    .GenerateReturn(表达式), 常量在中间代码生成通过AddConstant创建符号DST，然后生成中间代码RET DST;
    .GenerateJump 主要跳转到exit Basic Block. JMP exitBB
    .StartBBlock(CreateBBlock()); 因为return是一个跳转语句，如果return 1;后面还有代码，后面的代码所属就是该BBlock了
    .中间代码生成结束

## 汇编代码生成

    .从EmitFunction开始，函数序头函数序尾惯例
    .主要理解EmitBBlock,就是将Basic Block里面的IR inst全部转成汇编，其他的BB也这么操作
    .EmitIRInst就是个指针数组，就是根据中间代码的JMP,RET类型调用对应汇编代码生成函数
    .也就是EmitReturn和EmitJump
    .EmitReturn当然是把DST返回值放到EAX寄存器, movl $0 %eax
    .EmitJump生成 jmp .BB2(就是exitBB的label)
