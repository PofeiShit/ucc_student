# unary ->
---
简单记录.运算符
```
struct test
{
    int a;
};
void main()
{
    struct test *p;
    p->a = 10;
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	movl -4(%ebp), %eax
	movl (%eax), %ecx
	movl $10, (%ecx)
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
在expr.c的ParsePostfixExpression()添加TK_POINTER分支和TK_DOT共用

创建Expression节点，设置根节点op为OP_PTR_MEMBER,可以确定->操作符后面是a,所以根节点的成员变量val='a'，左子树指向节点p

## 语义分析
---
0.符号p的type为T(Pointer)->T(RecordType)

1.在exprchk.c的CheckPostfixExpression()添加OP_PTR_MEMBER分支，分支调用 CheckMemberAccess()进行语义检查，
expr->kids[0] = CheckExpression(expr->kids[0]); 对成员选择运算符的左操作数p进行语义检查, 得到p的类型:T(Pointer)->T(RecordType),然后获取根节点->的类型为T(RecordType)

2.LookupField()检查一下结构体 p 中是否有名字为 a 的域成员, 如果在结构体的定义中找不到成员 a，则说明 p->a 是非法的表达式,存在则得到符号a的信息

3.最后把查询得到的关于域成员 a 的类型信息，通过expr->val.p = fld存放到 p->a 表达式对应的语法树结点上，最后节点->的类型为符号a的类型T(INT)。合理

4.在语义检查后，域成员a在结构体struct test中的偏移量等信息由struct filed对象保存即expr->val.p = fld;而结构体对象test对应的符号则由 struct symbol 对象来存放.

5.整个CheckMemberAccess就是检查p->a表达式。

## 中间代码生成
---
当我们面对“p->a = 30;”时，UCC 编译器为p->a产生的中间代码如下所示，
```
t5: p
t6: t5 + 0; //成员a的偏移为0
t7: *t6;
```
由于t7是个临时变量，如果对t7进行赋值，则p->a的值并没有发生变化。我们要对t6所指向的内存单元进行赋值，才能改变p->a的值。
此时我们可产生形如“(IMOV, t6,30);”的中间代码，其中IMOV表示把30赋值给t6所指向的内存单元，而不是把30赋值给t6。UCC编译器的GenerateIndirectMove()函数用于产生IMOV指令。若t6的值存放在寄存器eax中，则最终生成的汇编代码可以是“movl $30, (%eax)”，对应的中间代码可表示为:*t6 = 30; //而不是 t6 = 30;

1.TranslatePostfixExpression添加OP_PTR_MEMBER分支,在分支中调用TranslateMemberAccess函数生成中间代码

2.在TranslateMemberAccess函数中添加expr->op==OP_PTR_MEMBER的条件用于计算“形如 p->a 的结构体成员”的基地址和常量偏移
```
    fld = p->val.p;
    coff = fld->offset;
    addr = TranslateExpression(expr->kids[0]);  // addr 就是基地址
```

3.dst = Deref(expr->ty, Simplify(T(POINTER), ADD, addr, IntConstant(coff))); Simplify 作用把a的地址加载到寄存器中, movl -4(%ebp), %eax; 如果有偏置的话:addl offset, %eax; offset=0则编译器会simplify的，就是这个函数的作用,
然后就是 Deref 解引用。也即是说10要赋值给的是%eax寄存器保存的地址里去，而不是赋值给%eax, 因此在这里，我们粗糙的再增加一条指令 movl (%eax), %ecx;

4.最后TranslateAssignmentExpression根据 expr->op==PTR_MEMBER 生成IndirectMove中间指令
通过GenerateIndirectMove(expr->ty, dst, src);产生一条 IMOV 指令(形如“*t = val;”)来实现赋值.也就是 movl $10, (%ecx)

## 汇编代码生成
---
EmitIndirectMove:
```
static void EmitIndirectMove(IRInst inst)
{
	Symbol reg;
    //把DST保存的地址放到某个寄存器中。假如%eax
	reg = PutInReg(DST);
	inst->opcode = MOV;
    // DST:(%eax) 通过()间接求得地址,然后将number赋值给(%eax)
	DST = reg->next;
    // src:10
    // 中间指令<MOV,(%eax),number,NULL> 对应（%eax) = number
	EmitMove(inst);
}
```
