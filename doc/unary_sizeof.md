# unary sizeof
---
简单记录sizeof运算符
```
void main()
{
    int a;
    a = sizeof a;
    a = sizeof(a);
}
```
未优化的汇编代码
```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	movl $4, -4(%ebp)
    movl $4, -4(%ebp)
.BB1:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

```

## 语法分析
---
在expr.c的ParseUnaryExpression()添加TK_SIZEOF分支，创建Expression节点，设置节点op为OP_SIZEOF,然后递归调用ParseUnaryExpression函数解析

## 语义分析
---
在exprchk.c添加 CheckUnaryExpression()添加OP_SIZEOF分支调用CheckExpression()获取sizeof对应的变量的ty，ty的成员size已经知道相应的大小，所以改变expr的op节点为OP_CONST，记录val.i[0] = ty->size.从这可以看出，sizeof在编译阶段的语义分析期间就结束了。生成了一个常量值。

## 中间代码生成
---
后面其实就是a=4的中间代码生成,TranslateExpression(a)的时候，因为a的op=OP_CONST,所以在TransPrimaryExpression走到OP_CONST分支，调用AddConstant创建SK_Constant的符号，生成MOV DST SRC1的中间指令

## 汇编代码生成
---
a=4的汇编代码生成。在EmitMove根据SRC1的符号类型(SK_Constant)调用 Move(X86_MOVI4, DST, SRC1);

# example
```
int arr[4];
int a;
typedef int bbb;
sizeof(a);
sizeof a;
sizeof(int);
sizeof(bbb);
a = sizeof(arr);
```
```
arr->size = 16;
movl $16, a;
```