# binary logical operator
记录下二元操作符 || 和 && 生成汇编
```
void main()
{
    int a;
    a || 3;
}

```
# Code auto-generated by UCC

.data

.text

.globl	main

main:
	pushl %ebp
	pushl %ebx
	pushl %esi
	pushl %edi
	movl %esp, %ebp
	subl $8, %esp
.BB0:
	cmpl $0, -4(%ebp)
	jne .BB3
.BB1:
	jmp .BB3
.BB2:
	movl $0, -8(%ebp)
	jmp .BB4
.BB3:
	movl $1, -8(%ebp)
.BB4:
.BB5:
	movl %ebp, %esp
	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret
```

## 中间代码生成
---
当我们遇到“a || b”时，“a ||b”实际上是个布尔表达式， 运算符||属于二元运算符，通过查表操作，我们会调用函数 TranslateBinaryExpression()来处理。由于当前运算符为||，即 OP_OR，此时条件会 成立，我们就会调用 TranslateBranchExpression()函数来生成以下代码:
```
BB10: //c=a||b 
    if (a) goto BB13;
BB11:
    if (b) goto BB13;
BB12:
    t = 0;
    goto BB14;
BB13:
    t = 1; 
BB14:
    c = t;
```
先介绍下TransBranchExpression函数
```
static Symbol TransBranchExpression(AstExpression expr)
{
	BBlock nextBB, trueBB, falseBB;
	Symbol t;
	t = CreateTemp(expr->ty); //创建临时变量t，需要根据布尔表达式的值(a || b)来控制t=0或者t=1的代码
	nextBB = CreateBBlock();
	trueBB = CreateBBlock(); // t = 1是基本块trueBB的第一条指令
	falseBB = CreateBBlock(); // 中间代码t = 0是基本快falseBB的第一条指令，
	TranslateBranch(expr, trueBB, falseBB); 
    // 上面这条代码生成如下汇编
    .BB0:
	    cmpl $0, -4(%ebp) // case OP中再递归调用GenerateBranch生成
	    jne .BB3
    .BB1:
	    jmp .BB3 // 30是OP_CONST直接调用GenerateJump(trueBB);
    //
	StartBBlock(falseBB);
    // t = 0
	GenerateMove(expr->ty, t, IntConstant(0)); // 产生t = 0的代码
    // 
    .BB2:
	    movl $0, -8(%ebp)
	    jmp .BB4
    //
	GenerateJump(nextBB); // 当表达式expr为假时，在执行完t=0后，还需要通过GenerateJump函数产生一条无条件跳转指令，跳过t=1的指令 
	StartBBlock(trueBB); 
	GenerateMove(expr->ty, t, IntConstant(1)); // 产生t = 1的代码
    //
    .BB3:
	    movl $1, -8(%ebp)
    .BB4:
    //
	StartBBlock(nextBB);
	return t;
}
在调用TranslateBranch(expr, bt, bn), 有两个调用约定:
1. 当expr为真时，跳往bt基本块
2. 紧随函数TranslateBranch()所生成的跳转指令之后的基本块为bn

void TranslateBranch(AstExpression expr, BBlock trueBB, BBlock falseBB)
{
	BBlock rtestBB;
	Symbol src1;
	Type ty;
	switch(expr->op) {
	case OP_CONST:
		if (! (expr->val.i[0] == 0 && expr->val.i[1] == 0))
		{			
			GenerateJump(trueBB);
		}
		break;
        
	case OP_OR:
		rtestBB = CreateBBlock(); // right test Basic Block   
		TranslateBranch(expr->kids[0], trueBB, rtestBB);      //    if (expr->kids[0]) goto trueBB  if (a) 
		StartBBlock(rtestBB);                                 // rtestBB:                           
		TranslateBranch(expr->kids[1], trueBB, falseBB);      //    if (expr->kids[1]) goto trueBB  kids[1]:30, 递归调用, OP_CONST
        // false basic block                                  // falseBB:
		break;
	default:
		src1 = TranslateExpression(expr);
		if (src1->kind == SK_Constant) {
			// TODO
		} else {
			ty = expr->ty;
			GenerateBranch(ty, trueBB, JNZ, src1, NULL); //  if src1 not zero jump trueBB (X86_JNZI4,    "cmpl $0, %1;jne %0")
		}
        // false
		break;
	}
}

/**
	GenerateBranch(choice->ty, lhalfBB, JL, choice, IntConstant(bucketArray[mid]->minVal));
	output:
		if (a < 1) goto BB5;
	@ty			the type of 'a'
	@dstBB		BB5
	@opcode		JL
	@src1		'a'
	@src2		1
 */
void GenerateBranch(Type ty, BBlock dstBB, int opcode, Symbol src1, Symbol src2)
{
	IRInst inst;

	ALLOC(inst);
	dstBB->ref++;
	src1->ref++;
	if (src2) src2->ref++;
	DrawCFGEdge(CurrentBB, dstBB);
	inst->ty = ty;
	inst->opcode  = opcode;
	inst->opds[0] = (Symbol)dstBB;
	inst->opds[1] = src1;
	inst->opds[2] = src2;
	AppendInst(inst);
}
```
